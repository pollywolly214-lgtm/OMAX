Website code:

Please add changes without conflict and adjust the format so that the categories window you are making is more legiable.

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/style.css b/style.css
index a4996017531e33a6f829e9623c878c12a2d459f1..b058fe5e29f7e7f25f17274b4ac2b61f7ee97c4e 100644
--- a/style.css
+++ b/style.css
@@ -1715,51 +1715,77 @@ body.modal-open .auth-bar {
 .total-hours-meta span { display: inline-flex; align-items: baseline; line-height: 1.2; }
 .total-hours-meta span + span::before { content: "•"; margin-right: 6px; color: #9aa4b2; }
 .total-hours-meta .hint,
 .total-hours-meta .small { margin: 0; }
 .job-edit-files { margin-top: 8px; display: flex; flex-direction: column; gap: 6px; }
 .job-file-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 4px; }
 .job-file-list li { display: flex; align-items: center; gap: 8px; font-size: 13px; }
 .job-file-list button.link { background: none; border: none; color: #c43d3d; cursor: pointer; padding: 0; font-size: 13px; }
 .job-file-list button.link:hover { text-decoration: underline; }
 .job-files-summary { margin-top: 4px; }
 
 .job-table {
   width: 100%;
   border-collapse: collapse;
   margin-top: 12px;
   font-variant-numeric: tabular-nums;
   background: #fff;
   border: 1px solid #dfe5f4;
   border-radius: 12px;
   overflow: hidden;
 }
 .job-page-toolbar {
   margin-top: 6px;
   margin-bottom: 6px;
   display: flex;
-  justify-content: flex-end;
+  justify-content: space-between;
+  align-items: center;
+  gap: 12px;
+  flex-wrap: wrap;
+}
+.job-category-filter {
+  display: inline-flex;
+  align-items: center;
+  gap: 8px;
+  font-size: 13px;
+  color: #2a3b5c;
+}
+.job-category-filter span {
+  font-weight: 600;
+}
+.job-category-filter select {
+  min-width: 160px;
+  padding: 6px 8px;
+  border-radius: 8px;
+  border: 1px solid rgba(15, 52, 104, 0.2);
+  box-shadow: inset 0 1px 2px rgba(13, 36, 72, 0.08);
+  font-size: 13px;
+  background-color: #fff;
+}
+.job-category-filter select:focus {
+  outline: 2px solid rgba(33, 150, 243, 0.35);
+  border-color: rgba(33, 150, 243, 0.55);
 }
 .job-history-button {
   display: inline-flex;
   align-items: center;
   gap: 6px;
   padding: 6px 14px;
   border-radius: 999px;
   border: 1px solid #1f3b67;
   background: #1f3b67;
   color: #fff;
   font-weight: 600;
   font-size: 13px;
   text-decoration: none;
   transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
 }
 .job-history-button:hover,
 .job-history-button:focus {
   background: #264b84;
   border-color: #264b84;
 }
 .job-history-button:focus-visible {
   outline: 2px solid #91b7ff;
   outline-offset: 2px;
 }
 .job-table thead th {
@@ -1780,51 +1806,70 @@ body.modal-open .auth-bar {
   font-size: 14px;
   color: #1c2d4a;
 }
 .job-row + .job-detail-row td {
   border-top: 0;
   background: #f9fbff;
 }
 .job-col {
   min-width: 0;
 }
 .job-col-estimate,
 .job-col-input,
 .job-col-money,
 .job-col-hours,
 .job-col-need,
 .job-col-impact,
 .job-col-charge,
 .job-col-cost,
 .job-col-net {
   text-align: right;
   white-space: nowrap;
 }
 .job-main {
   display: flex;
   flex-direction: column;
-  gap: 2px;
+  gap: 4px;
+}
+.job-main-category-picker {
+  display: inline-flex;
+  align-items: center;
+  gap: 6px;
+  color: #5d6470;
+  font-size: 12px;
+}
+.job-main-category-picker select {
+  padding: 4px 6px;
+  border-radius: 6px;
+  border: 1px solid rgba(15, 52, 104, 0.2);
+  box-shadow: inset 0 1px 2px rgba(13, 36, 72, 0.08);
+  font-size: 12px;
+  background-color: #fff;
+}
+.job-main-category-picker select:focus {
+  outline: 2px solid rgba(33, 150, 243, 0.35);
+  border-color: rgba(33, 150, 243, 0.55);
 }
 .job-main strong {
   font-size: 16px;
   color: #13233f;
 }
 .job-main-dates {
   font-size: 13px;
   color: #637192;
 }
 .job-col-material {
   color: #2a3b5c;
   font-weight: 500;
 }
 .job-input {
   width: 100%;
   padding: 6px 8px;
   border-radius: 8px;
   border: 1px solid rgba(15, 52, 104, 0.2);
   font-size: 13px;
   box-shadow: inset 0 1px 2px rgba(13, 36, 72, 0.08);
 }
 .job-input:focus {
   outline: 2px solid rgba(33, 150, 243, 0.35);
   border-color: rgba(33, 150, 243, 0.55);
 }
@@ -3036,50 +3081,71 @@ th { background: linear-gradient(135deg, rgba(9, 68, 165, 0.85), rgba(33, 182, 2
 .modal-close {
   position: absolute;
   top: 10px;
   right: 12px;
   border: 0;
   background: none;
   font-size: 1.6rem;
   line-height: 1;
   cursor: pointer;
   color: #4b5563;
 }
 
 .modal-close:hover {
   color: #1f2937;
 }
 
 body.modal-open {
   overflow: hidden;
 }
 
 .dash-modal-step[hidden] { display: none; }
 .inventory-modal-card{ width:min(520px,94vw); }
 .inventory-modal-step p{ margin:0 0 12px; }
 .inventory-modal-actions{ flex-wrap:wrap; }
 
+.job-page-container{ grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); }
+.job-category-panel{ display:flex; flex-direction:column; gap:12px; }
+.job-category-header{ display:flex; justify-content:space-between; align-items:center; gap:12px; }
+.job-category-tree{ display:flex; flex-direction:column; gap:10px; padding:8px 0; }
+.job-folder{ border:1px solid #d6d7da; border-radius:12px; padding:6px; background:#fff; display:flex; flex-direction:column; gap:6px; }
+.job-folder-row{ display:flex; justify-content:space-between; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; transition:background 0.18s ease, color 0.18s ease; flex-wrap:wrap; row-gap:6px; }
+.job-folder-row:not(.job-folder-row-selected):hover{ background:rgba(12, 37, 84, 0.08); }
+.job-folder-row-selected{ background:#0a63c2; color:#fff; box-shadow:0 12px 24px rgba(10, 44, 96, 0.28); }
+.job-folder-row-selected .job-folder-count{ color:#f0f4ff; background:rgba(255,255,255,0.18); }
+.job-folder-select{ background:none; border:none; padding:0; font-weight:600; font-size:14px; cursor:pointer; text-align:left; color:inherit; max-width:100%; }
+.job-folder-select:hover{ text-decoration:underline; }
+.job-folder-select:focus-visible{ outline:2px solid rgba(59,130,246,0.75); outline-offset:2px; border-radius:6px; }
+.job-folder-count{ font-size:12px; color:#5d6470; display:inline-flex; align-items:center; gap:6px; padding:3px 10px; border-radius:999px; background:rgba(12, 37, 84, 0.08); line-height:1.3; white-space:nowrap; }
+.job-folder-actions{ margin-top:6px; display:flex; flex-wrap:wrap; gap:6px; font-size:12px; }
+.job-folder-actions .link{ font-size:12px; padding:0; }
+.job-folder-action-sep{ color:#b0b4bb; }
+.job-folder-children{ margin-top:8px; margin-left:12px; display:flex; flex-direction:column; gap:8px; }
+.job-main-block{ grid-column:span 2; }
+.job-main-category{ font-size:12px; color:#5d6470; }
+@media (max-width:900px){ .job-main-block{ grid-column:span 1; } }
+
 .modal-grid {
   display: grid;
   grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
   gap: 12px;
 }
 
 .modal-grid label {
   display: flex;
   flex-direction: column;
   font-size: 0.9rem;
   gap: 4px;
   color: inherit;
 }
 
 .modal-grid input,
 .modal-grid select {
   padding: 0.45rem 0.55rem;
   border: 1px solid #cdd4e1;
   border-radius: 6px;
   font-size: 0.95rem;
   color: #0b1120;
   background: #fff;
 }
 
 .task-option-stage { 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/js/views.js b/js/views.js
index 0d60d74cdc5e4e164d13a922a85ac2c4d7e18861..6c704798b395b09b5eb9c44077d04cbf63f2cd4d 100644
--- a/js/views.js
+++ b/js/views.js
@@ -7,50 +7,83 @@ function viewDashboard(){
   const lastEntry = totalHistory.length ? totalHistory[totalHistory.length - 1] : null;
   const lastUpdated = cur!=null && lastEntry && lastEntry.dateISO
     ? new Date(lastEntry.dateISO).toLocaleString()
     : "—";
   const efficiencyWindows = (Array.isArray(TIME_EFFICIENCY_WINDOWS) && TIME_EFFICIENCY_WINDOWS.length)
     ? TIME_EFFICIENCY_WINDOWS
     : [
         { key: "7d", label: "1W", days: 7, description: "Past 7 days" },
         { key: "30d", label: "1M", days: 30, description: "Past 30 days" },
         { key: "90d", label: "3M", days: 90, description: "Past 3 months" },
         { key: "182d", label: "6M", days: 182, description: "Past 6 months" },
         { key: "365d", label: "1Y", days: 365, description: "Past year" }
       ];
   const efficiencyButtons = efficiencyWindows.map((win, index) => {
     const days = Number(win?.days) || 0;
     const label = esc(win?.label ?? `${days || ""}`);
     const description = esc(win?.description ?? (days ? `Past ${days} days` : "Selected window"));
     const isActive = index === 0;
     return `
       <button type="button" class="time-efficiency-toggle${isActive ? " is-active" : ""}" data-efficiency-range="${esc(String(days))}" data-efficiency-range-label="${description}" aria-pressed="${isActive ? "true" : "false"}" title="${description}">
         ${label}
       </button>
     `;
   }).join("");
   const defaultEfficiencyDescription = esc(efficiencyWindows[0]?.description || "Past 7 days");
+
+  const jobRootId = typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root";
+  const jobFolders = Array.isArray(window.jobFolders) && window.jobFolders.length
+    ? window.jobFolders.slice()
+    : defaultJobFolders();
+  if (!jobFolders.some(folder => String(folder.id) === jobRootId)){
+    jobFolders.push({ id: jobRootId, name: "All Jobs", parent: null, order: 1 });
+  }
+  const sortJobFolders = (list)=> list.slice().sort((a,b)=>{
+    const orderDiff = (Number(b?.order) || 0) - (Number(a?.order) || 0);
+    if (orderDiff !== 0) return orderDiff;
+    return String(a?.name || "").localeCompare(String(b?.name || ""));
+  });
+  const jobChildrenOf = (parentId)=>{
+    const key = parentId == null ? null : String(parentId);
+    return sortJobFolders(jobFolders.filter(folder => {
+      const parentKey = folder.parent == null ? null : String(folder.parent);
+      return parentKey === key;
+    }));
+  };
+  const jobFolderOptions = [];
+  const appendJobFolderOption = (folder, depth)=>{
+    if (!folder) return;
+    const indent = depth ? Array(depth).fill("&nbsp;&nbsp;").join("") : "";
+    const prefix = depth ? "↳ " : "";
+    const name = esc(folder.name || (String(folder.id) === jobRootId ? "All Jobs" : "Category"));
+    jobFolderOptions.push({ id: String(folder.id), label: `${indent}${prefix}${name}` });
+    jobChildrenOf(folder.id).forEach(child => appendJobFolderOption(child, depth + 1));
+  };
+  const jobRootFolder = jobFolders.find(folder => String(folder.id) === jobRootId) || { id: jobRootId, name: "All Jobs", parent: null, order: 1 };
+  appendJobFolderOption(jobRootFolder, 0);
+  const dashboardCategoryOptions = jobFolderOptions.map(option => `<option value="${esc(option.id)}">${option.label}</option>`).join("");
+
   return `
   <div class="container">
     <div class="dashboard-toolbar">
       <span class="dashboard-edit-hint" id="dashboardEditHint" hidden>Drag windows to rearrange and resize. Calendar stays fixed.</span>
     </div>
 
     <div class="dashboard-layout" id="dashboardLayout">
       <div class="dashboard-window" data-dashboard-window="totalHours">
         <div class="block total-hours-block">
           <h3>Total Hours</h3>
           <div class="total-hours-controls mini-form">
             <label class="total-hours-label"><span>Enter total hours now:</span>
               <input type="number" id="totalInput" value="${cur!=null?cur:""}" />
             </label>
             <button id="logBtn">Log Hours</button>
           </div>
           <div class="total-hours-meta" aria-live="polite">
             <span class="hint">Last updated: ${lastUpdated}</span>
             <span class="small">Δ since last: <b>${(delta||0).toFixed(0)} hrs</b>${prev!=null? " (prev "+prev+")":""}</span>
           </div>
         </div>
       </div>
 
       <div class="dashboard-window" data-dashboard-window="nextDue">
         <div class="block next-due-block">
@@ -243,50 +276,54 @@ function viewDashboard(){
             <label>Notes<input id="dashGarnetNote" placeholder="Optional note"></label>
           </div>
           <div class="modal-actions garnet-actions">
             <button type="button" class="secondary" data-step-back>Back</button>
             <div class="garnet-action-buttons">
               <button type="button" class="secondary" id="dashGarnetCancel" hidden>Cancel edit</button>
               <button type="submit" class="primary" id="dashGarnetSubmit">Add Cleaning</button>
             </div>
           </div>
         </form>
         <div id="dashGarnetList" class="garnet-list"></div>
       </section>
 
       <section class="dash-modal-step" data-step="job" hidden>
         <h4>Add cutting job</h4>
         <form id="dashJobForm" class="modal-form">
           <div class="modal-grid">
             <label>Job name<input id="dashJobName" required placeholder="Job"></label>
             <label>Estimate (hrs)<input type="number" min="1" step="0.1" id="dashJobEstimate" required placeholder="e.g. 12"></label>
             <label>Charge rate ($/hr)<input type="number" min="0" step="0.01" id="dashJobCharge" placeholder="Optional"></label>
             <label>Material<input id="dashJobMaterial" placeholder="Material"></label>
             <label>Material cost ($)<input type="number" min="0" step="0.01" id="dashJobMaterialCost" placeholder="optional"></label>
             <label>Material quantity<input type="number" min="0" step="0.01" id="dashJobMaterialQty" placeholder="optional"></label>
             <label>Start date<input type="date" id="dashJobStart" required></label>
             <label>Due date<input type="date" id="dashJobDue" required></label>
+            <label>Category<select id="dashJobCategory">
+              ${dashboardCategoryOptions}
+              <option value="__new__">+ Create new category…</option>
+            </select></label>
           </div>
           <div class="modal-actions">
             <button type="button" class="secondary" data-step-back>Back</button>
             <button type="submit" class="primary">Add Job</button>
           </div>
         </form>
       </section>
     </div>
   </div>`;
 }
 
 function taskDetailsInterval(task){
   const nd = nextDue(task);
   const sinceTxt = nd ? `${nd.since.toFixed(0)} / ${task.interval} hrs` : "—";
   const daysTxt  = nd ? `${nd.days} day(s) → ${nd.due.toDateString()}` : "—";
   const lastServ = nd && nd.lastServicedAt != null ? `${nd.lastServicedAt.toFixed(0)} hrs` : "—";
   return `
 <details data-task-id="${task.id}" data-list="interval">
     <summary>${task.name} — <span class="small">since: ${sinceTxt} | due: ${daysTxt}</span></summary>
     <div class="row"><label>Name:</label>
       <div><input type="text" data-k="name" data-id="${task.id}" data-list="interval" value="${task.name}" /></div>
     </div>
     <div class="row"><label>Interval (hrs):</label>
       <div><input type="number" min="1" data-k="interval" data-id="${task.id}" data-list="interval" value="${task.interval}" /></div>
     </div>
@@ -1502,233 +1539,370 @@ function viewJobs(){
     : (()=>{
         if (!(window.editingCompletedJobs instanceof Set)){
           window.editingCompletedJobs = new Set();
         }
         return window.editingCompletedJobs;
       })();
 
   const matchesHistorySearch = (job)=>{
     if (!job) return false;
     if (!historyQuery) return true;
     if (editingCompletedJobsSet.has(String(job.id))) return true;
     const eff = job && job.efficiency ? job.efficiency : {};
     const delta = Number(eff.deltaHours);
     const netTotal = computeJobNetTotal(job, eff, { preferActual: true });
     const actualHours = Number(job.actualHours ?? eff.actualHours);
     const estHours = Number(job.estimateHours);
     const statusLabel = Number.isFinite(delta) && Math.abs(delta) > 0.1
       ? (delta > 0 ? "Finished ahead" : "Finished behind")
       : "Finished on estimate";
     const statusDetail = Number.isFinite(delta) && Math.abs(delta) > 0.1
       ? `${delta > 0 ? "+" : "-"}${Math.abs(delta).toFixed(1)} hr`
       : "";
     const completedLabel = formatDate(job?.completedAtISO);
     const startLabel = formatDate(job?.startISO);
     const dueLabel = formatDate(job?.dueISO);
+    const categoryLabel = folderMap.get(normalizeCategory(job?.cat))?.name || "";
     const actualLabel = formatHours(actualHours);
     const estimateLabel = formatHours(estHours);
     const tokens = [
       job.id,
       job.name,
       job.material,
       job.notes,
       job.completedAtISO,
       job.startISO,
       job.dueISO,
+      categoryLabel,
       statusLabel,
       statusDetail,
       Number.isFinite(delta) ? delta.toFixed(1) : "",
       Number.isFinite(delta) ? (delta > 0 ? "ahead" : delta < 0 ? "behind" : "on pace") : "",
       Number.isFinite(netTotal) ? netTotal.toString() : ""
     ];
     [completedLabel, startLabel, dueLabel].forEach(label => {
       if (label && label !== "—") tokens.push(label);
     });
     if (actualLabel && actualLabel !== "—") tokens.push(actualLabel);
     if (estimateLabel && estimateLabel !== "—") tokens.push(estimateLabel);
     if (actualLabel && estimateLabel && actualLabel !== "—" && estimateLabel !== "—"){
       tokens.push(`${actualLabel} / ${estimateLabel}`);
     }
     if (Number.isFinite(netTotal)){
       tokens.push(formatCurrency(netTotal));
       tokens.push(formatCurrency(netTotal, { showPlus: false }));
     }
     const numericFields = [
       job.materialCost,
       job.materialQty,
       job.actualHours,
       job.estimateHours,
       eff.actualHours,
       eff.expectedHours,
       eff.expectedRemaining,
       eff.actualRemaining
     ];
     numericFields.forEach(value => {
       if (value == null || value === "") return;
       tokens.push(String(value));
     });
     return tokens.some(field => {
       if (field == null) return false;
       const text = String(field).trim();
       if (!text) return false;
       return text.toLowerCase().includes(historyQuery);
     });
   };
 
-  const completedFiltered = completedSorted.filter(matchesHistorySearch);
-  const completedStats = completedFiltered.reduce((acc, job)=>{
-    const eff = job && job.efficiency ? job.efficiency : {};
-    const net = computeJobNetTotal(job, eff, { preferActual: true });
-    acc.total += Number.isFinite(net) ? net : 0;
-    return acc;
-  }, { total: 0 });
-  const completedAverage = completedFiltered.length ? (completedStats.total / completedFiltered.length) : 0;
   const numberInputValue = (value)=>{
     const num = Number(value);
     return Number.isFinite(num) ? String(num) : "";
   };
   const formatDateTimeLocal = (iso)=>{
     if (!iso) return "";
     const dt = new Date(iso);
     if (!(dt instanceof Date) || Number.isNaN(dt.getTime())) return "";
     const offset = dt.getTimezoneOffset();
     const local = new Date(dt.getTime() - offset * 60000);
     return local.toISOString().slice(0,16);
   };
 
+  const rootCategoryId = typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root";
+  const jobFolders = Array.isArray(window.jobFolders) && window.jobFolders.length
+    ? window.jobFolders.slice()
+    : defaultJobFolders();
+  if (!jobFolders.some(folder => String(folder.id) === rootCategoryId)){
+    jobFolders.push({ id: rootCategoryId, name: "All Jobs", parent: null, order: 1 });
+  }
+  const folderMap = new Map(jobFolders.map(folder => [String(folder.id), folder]));
+  const parentMap = new Map(jobFolders.map(folder => [String(folder.id), folder.parent == null ? null : String(folder.parent)]));
+  const normalizeCategory = (cat)=>{
+    const key = cat != null ? String(cat) : rootCategoryId;
+    if (folderMap.has(key)) return key;
+    return rootCategoryId;
+  };
+  const selectedCategoryRaw = typeof window.jobCategoryFilter === "string" ? window.jobCategoryFilter : rootCategoryId;
+  const selectedCategory = folderMap.has(String(selectedCategoryRaw)) ? String(selectedCategoryRaw) : rootCategoryId;
+  window.jobCategoryFilter = selectedCategory;
+
+  const sortFolders = (list)=> list.slice().sort((a, b)=>{
+    const orderDiff = (Number(b?.order) || 0) - (Number(a?.order) || 0);
+    if (orderDiff !== 0) return orderDiff;
+    return String(a?.name || "").localeCompare(String(b?.name || ""));
+  });
+
+  const childrenOf = (parentId)=>{
+    const key = parentId == null ? null : String(parentId);
+    return sortFolders(jobFolders.filter(folder => {
+      const parentKey = folder.parent == null ? null : String(folder.parent);
+      return parentKey === key;
+    }));
+  };
+
+  const includeDescendants = (categoryId, acc)=>{
+    const key = String(categoryId);
+    if (acc.has(key)) return;
+    acc.add(key);
+    const kids = childrenOf(categoryId);
+    kids.forEach(child => includeDescendants(child.id, acc));
+  };
+
+  const allowedCategories = new Set();
+  includeDescendants(selectedCategory, allowedCategories);
+
+  const activeCounts = new Map();
+  const completedCounts = new Map();
+  const incrementCounts = (map, catId)=>{
+    let current = normalizeCategory(catId);
+    while (current){
+      map.set(current, (map.get(current) || 0) + 1);
+      const parent = parentMap.get(current);
+      if (parent == null) break;
+      current = String(parent);
+    }
+  };
+
+  cuttingJobs.forEach(job => incrementCounts(activeCounts, job?.cat));
+  completedCuttingJobs.forEach(job => incrementCounts(completedCounts, job?.cat));
+
+  const folderOptions = [];
+  const ensureFolderEntry = (folder, depth)=>{
+    if (!folder) return;
+    const id = String(folder.id);
+    const indent = depth ? Array(depth).fill("&nbsp;&nbsp;").join("") : "";
+    const prefix = depth ? "↳ " : "";
+    const safeLabel = esc(folder.name || (id === rootCategoryId ? "All Jobs" : "Category"));
+    folderOptions.push({ id, label: `${indent}${prefix}${safeLabel}` });
+    const kids = childrenOf(folder.id);
+    kids.forEach(child => ensureFolderEntry(child, depth + 1));
+  };
+  const rootFolder = folderMap.get(rootCategoryId) || { id: rootCategoryId, name: "All Jobs", parent: null, order: 1 };
+  ensureFolderEntry(rootFolder, 0);
+
+  const categoryOptionsMarkup = (selectedId, { includeCreateOption = false, rootLabel } = {})=>{
+    const target = normalizeCategory(selectedId);
+    const optionsHtml = folderOptions.map(option => {
+      const selectedAttr = option.id === target ? " selected" : "";
+      const label = option.id === rootCategoryId && rootLabel ? esc(rootLabel) : option.label;
+      return `<option value="${esc(option.id)}"${selectedAttr}>${label}</option>`;
+    }).join("");
+    if (!includeCreateOption) return optionsHtml;
+    return `${optionsHtml}<option value="__new__">+ Create new category…</option>`;
+  };
+
+  const renderFolderTree = (folder)=>{
+    if (!folder) return "";
+    const id = String(folder.id);
+    const isRoot = id === rootCategoryId;
+    const selectedClass = id === selectedCategory ? " job-folder-row-selected" : "";
+    const activeCount = activeCounts.get(id) || 0;
+    const completedCount = completedCounts.get(id) || 0;
+    const countParts = [];
+    if (activeCount > 0) countParts.push(`${activeCount} active`);
+    if (completedCount > 0) countParts.push(`${completedCount} archived`);
+    const countLabel = countParts.length ? `<span class="job-folder-count">${countParts.join(" · ")}</span>` : "";
+    const actions = [
+      `<button type="button" class="link" data-job-folder-add="${esc(id)}">+ Sub-category</button>`,
+      !isRoot ? `<button type="button" class="link" data-job-folder-rename="${esc(id)}">Rename</button>` : "",
+      !isRoot ? `<button type="button" class="link danger" data-job-folder-remove="${esc(id)}">Remove</button>` : ""
+    ].filter(Boolean).join("<span class=\"job-folder-action-sep\" aria-hidden=\"true\">·</span>");
+    const childrenMarkup = childrenOf(folder.id).map(child => renderFolderTree(child)).join("");
+    return `
+      <div class="job-folder" data-job-folder="${esc(id)}">
+        <div class="job-folder-row${selectedClass}">
+          <button type="button" class="job-folder-select" data-job-folder-select="${esc(id)}" aria-current="${id === selectedCategory ? "true" : "false"}">
+            ${esc(folder.name || (isRoot ? "All Jobs" : "Category"))}
+          </button>
+          ${countLabel}
+        </div>
+        <div class="job-folder-actions">${actions || ""}</div>
+        ${childrenMarkup ? `<div class="job-folder-children">${childrenMarkup}</div>` : ""}
+      </div>
+    `;
+  };
+
+  const folderTreeMarkup = renderFolderTree(rootFolder);
+
+  const jobsForCategory = cuttingJobs.filter(job => {
+    const normalized = normalizeCategory(job?.cat);
+    return allowedCategories.has(normalized);
+  });
+
+  const completedForCategory = completedSorted.filter(job => {
+    const normalized = normalizeCategory(job?.cat);
+    return allowedCategories.has(normalized);
+  });
+
+  const completedFiltered = completedForCategory.filter(matchesHistorySearch);
+  const completedStats = completedFiltered.reduce((acc, job)=>{
+    const eff = job && job.efficiency ? job.efficiency : {};
+    const net = computeJobNetTotal(job, eff, { preferActual: true });
+    acc.total += Number.isFinite(net) ? net : 0;
+    return acc;
+  }, { total: 0 });
+  const completedAverage = completedFiltered.length ? (completedStats.total / completedFiltered.length) : 0;
+
   const historyColumnCount = 7;
   const historySearchDisplay = historySearchValue
     .replace(/&/g, "&amp;")
     .replace(/</g, "&lt;")
     .replace(/>/g, "&gt;")
     .replace(/"/g, "&quot;");
   const completedRows = completedFiltered.map(job => {
     const eff = job && job.efficiency ? job.efficiency : {};
     const delta = Number(eff.deltaHours);
     const netTotal = computeJobNetTotal(job, eff, { preferActual: true });
     const actualHours = Number(job.actualHours ?? eff.actualHours);
     const estHours = Number(job.estimateHours);
     const editingHistory = editingCompletedJobsSet.has(String(job.id));
+    const categoryFolder = folderMap.get(normalizeCategory(job?.cat));
     let statusLabel = "Finished on estimate";
     if (Number.isFinite(delta) && Math.abs(delta) > 0.1){
       statusLabel = delta > 0 ? "Finished ahead" : "Finished behind";
     }
     const statusDetail = Number.isFinite(delta) && Math.abs(delta) > 0.1
       ? ` (${delta > 0 ? "+" : "−"}${Math.abs(delta).toFixed(1)} hr)`
       : "";
     const noteDisplay = job?.notes
       ? esc(String(job.notes)).replace(/\n/g, "<br>")
       : "<span class=\"muted\">—</span>";
     const materialLine = job?.material ? `<div class="small muted">${esc(job.material)}</div>` : "";
+    const categoryLine = categoryFolder ? `<div class="small muted">${esc(categoryFolder.name || "All Jobs")}</div>` : "";
 
     if (!editingHistory){
       return `
         <tr data-history-row="${job.id || ""}">
           <td>
             <div><strong>${esc(job?.name || "Job")}</strong></div>
+            ${categoryLine}
             ${materialLine}
           </td>
           <td>${formatDate(job?.completedAtISO)}</td>
           <td>${formatHours(actualHours)} / ${formatHours(estHours)}</td>
           <td>${esc(statusLabel)}${statusDetail}</td>
           <td>${formatCurrency(netTotal)}</td>
           <td>${noteDisplay}</td>
           <td class="past-job-actions">
             <button type="button" data-history-activate="${job.id}">Make active copy</button>
             <button type="button" data-history-edit="${job.id}">Edit</button>
             <button type="button" class="danger" data-history-delete="${job.id}">Delete</button>
           </td>
         </tr>
       `;
     }
 
     const completedVal = formatDateTimeLocal(job?.completedAtISO);
     const actualVal = numberInputValue(actualHours);
     const estimateVal = numberInputValue(estHours);
     const materialCostVal = numberInputValue(job?.materialCost);
     const materialQtyVal = numberInputValue(job?.materialQty);
 
     return `
       <tr data-history-row="${job.id || ""}" class="editing">
         <td colspan="${historyColumnCount}">
           <div class="past-job-edit">
             <div class="past-job-edit-grid">
               <label>Job name<input type="text" data-history-field="name" data-history-id="${job.id}" value="${esc(job?.name || "")}"></label>
               <label>Completed at<input type="datetime-local" data-history-field="completedAtISO" data-history-id="${job.id}" value="${completedVal}"></label>
               <label>Estimate (hrs)<input type="number" min="0" step="0.1" data-history-field="estimateHours" data-history-id="${job.id}" value="${estimateVal}"></label>
               <label>Actual (hrs)<input type="number" min="0" step="0.1" data-history-field="actualHours" data-history-id="${job.id}" value="${actualVal}"></label>
               <label>Material<input type="text" data-history-field="material" data-history-id="${job.id}" value="${esc(job?.material || "")}"></label>
               <label>Material cost<input type="number" min="0" step="0.01" data-history-field="materialCost" data-history-id="${job.id}" value="${materialCostVal}"></label>
               <label>Material quantity<input type="number" min="0" step="0.01" data-history-field="materialQty" data-history-id="${job.id}" value="${materialQtyVal}"></label>
+              <label>Category<select data-history-field="cat" data-history-id="${job.id}" data-job-category-select>
+                ${categoryOptionsMarkup(job.cat, { includeCreateOption: true })}
+              </select></label>
             </div>
             <label class="past-job-edit-notes">Notes<textarea data-history-field="notes" data-history-id="${job.id}" rows="3">${textEsc(job?.notes || "")}</textarea></label>
             <div class="past-job-edit-actions">
               <button type="button" data-history-save="${job.id}">Save</button>
               <button type="button" class="danger" data-history-cancel="${job.id}">Cancel</button>
             </div>
           </div>
         </td>
       </tr>
     `;
   }).join("");
   const historySearchActive = historyQuery.length > 0;
-  const totalCompletedCount = completedSorted.length;
+  const totalCompletedCount = completedForCategory.length;
   const historyEmptyMessage = historySearchActive
     ? "No past cutting jobs match your search."
     : "Mark jobs complete to build a history of past cutting work.";
   const completedTable = completedFiltered.length
     ? `
       <div class="past-jobs-summary">
         <div><span class="label">Jobs logged</span><span>${completedFiltered.length}</span></div>
         <div><span class="label">Total impact</span><span>${formatCurrency(completedStats.total)}</span></div>
         <div><span class="label">Avg per job</span><span>${formatCurrency(completedAverage)}</span></div>
       </div>
       <table class="past-jobs-table">
         <thead>
           <tr><th>Job</th><th>Completed</th><th>Actual vs estimate</th><th>Status</th><th>Net total</th><th>Note</th><th>Actions</th></tr>
         </thead>
         <tbody>${completedRows}</tbody>
       </table>
     `
     : `<p class="small muted">${historyEmptyMessage}</p>`;
   const historyFilterStatus = historySearchActive
     ? `<div class="small muted past-jobs-filter-status">Showing ${completedFiltered.length} of ${totalCompletedCount} logged jobs.</div>`
     : "";
   const activeColumnCount = 14;
-  const rows = cuttingJobs.map(j => {
+  const rows = jobsForCategory.map(j => {
     const jobFiles = Array.isArray(j.files) ? j.files : [];
     const fileLinks = jobFiles.length
       ? `<ul class="job-file-pill-list">${jobFiles.map((f, idx) => {
           const safeName = f.name || `file_${idx+1}`;
           const href = f.dataUrl || f.url || "";
           if (!href) return "";
           return `<li><a href="${href}" download="${safeName}" class="job-file-pill">${safeName}</a></li>`;
         }).filter(Boolean).join("")}</ul>`
       : `<p class="small muted">No files attached. Edit the job to add files.</p>`;
     const eff = computeJobEfficiency(j);
     const req = computeRequiredDaily(j);
     const editing = editingJobs.has(j.id);
+    const categoryFolder = folderMap.get(normalizeCategory(j.cat));
+    const categoryName = categoryFolder ? categoryFolder.name || "All Jobs" : "All Jobs";
 
     // Material totals
     const matCost = Number(j.materialCost||0);
     const matQty  = Number(j.materialQty||0);
     const matTotal = (matCost * matQty) || 0;
     const estHours = Number(j.estimateHours) || 0;
     const chargeRateRaw = Number(j.chargeRate);
     const chargeRate = Number.isFinite(chargeRateRaw) && chargeRateRaw >= 0 ? chargeRateRaw : JOB_RATE_PER_HOUR;
     const costRate = JOB_BASE_COST_PER_HOUR + (estHours > 0 ? (matTotal / estHours) : 0);
     const netRate = chargeRate - costRate;
     const chargeDisplay = formatRate(chargeRate);
     const costDisplay = formatRate(costRate);
     const netDisplay = formatRate(netRate, { showPlus: true });
     const netClass = netRate >= 0 ? "job-rate-net-positive" : "job-rate-net-negative";
     const netTotal = computeJobNetTotal(j, eff, { preferActual: false });
     const netTotalDisplay = formatCurrency(netTotal, { showPlus: true });
     const impactClass = netTotal > 0 ? "job-impact-ahead" : (netTotal < 0 ? "job-impact-behind" : "job-impact-neutral");
 
     // Remaining & per-day
     const actualRemain = eff.actualRemaining != null ? eff.actualRemaining : (req.remainingHours || 0);
     const remainHrs = actualRemain;
     const needPerDay = req.requiredPerDay === Infinity
       ? '∞'
       : (req.requiredPerDay||0).toFixed(2);
     const remainingHours = Number.isFinite(req.remainingHours) ? Math.max(0, req.remainingHours) : 0;
@@ -1769,50 +1943,56 @@ function viewJobs(){
       : `${needPerDay} hr/day needed (capacity ${hoursPerDay.toFixed(1)} hr/day)`;
     const statusDisplay = [
       `<div class="job-status ${aheadSchedule ? 'job-status-ahead' : (behindSchedule ? 'job-status-behind' : 'job-status-onpace')}">${esc(statusLabel)}</div>`,
       statusDetail ? `<div class="job-status-detail">${esc(statusDetail.trim())}</div>` : ''
     ].join('');
 
     // Dates (for display / edit row)
     const startDate = parseDateLocal(j.startISO);
     const dueDate   = parseDateLocal(j.dueISO);
     const startTxt  = startDate ? startDate.toDateString() : "—";
     const dueTxt    = dueDate ? dueDate.toDateString() : "—";
     const dueVal    = dueDate ? ymd(dueDate) : (j.dueISO || "");
 
     if (!editing){
       const matCostDisplay = formatCurrency(matCost, { showPlus: false });
       const matQtyDisplay  = formatQuantity(matQty);
       const noteContent = (j.notes || "").trim();
       const noteMarkup = noteContent
         ? `<div id="jobNote_${j.id}" class="job-note-display" data-requires-edit="${j.id}">${textEsc(j.notes || "").replace(/\n/g, "<br>")}</div>`
         : `<div id="jobNote_${j.id}" class="job-note-display job-note-empty" data-requires-edit="${j.id}">Add a note…</div>`;
       return `
         <tr data-job-row="${j.id}" class="job-row">
           <td class="job-col job-col-main job-col-locked" data-requires-edit="${j.id}">
             <div class="job-main">
               <strong>${j.name}</strong>
+              <div class="job-main-category small muted">Category: ${esc(categoryName)}</div>
+              <label class="job-main-category-picker small">Move to
+                <select data-job-category-inline="${esc(j.id)}" data-job-category-select aria-label="Change category for ${esc(j.name || "Job")}">
+                  ${categoryOptionsMarkup(j.cat, { includeCreateOption: true })}
+                </select>
+              </label>
               <div class="job-main-dates">${startTxt} → ${dueTxt}</div>
             </div>
           </td>
           <td class="job-col job-col-estimate job-col-locked" data-requires-edit="${j.id}">${estimateDisplay}</td>
           <td class="job-col job-col-material job-col-locked" data-requires-edit="${j.id}">${j.material || '—'}</td>
           <td class="job-col job-col-input job-col-locked" data-requires-edit="${j.id}">${matCostDisplay}</td>
           <td class="job-col job-col-input job-col-locked" data-requires-edit="${j.id}">${matQtyDisplay}</td>
           <td class="job-col job-col-money">$${matTotal.toFixed(2)}</td>
           <td class="job-col job-col-charge">${chargeDisplay}</td>
           <td class="job-col job-col-cost">${costDisplay}</td>
           <td class="job-col job-col-net"><span class="job-rate-net ${netClass}">${netDisplay}</span></td>
           <td class="job-col job-col-hours">${remainingDisplay}</td>
           <td class="job-col job-col-need">${needDisplay}</td>
           <td class="job-col job-col-status">${statusDisplay}</td>
           <td class="job-col job-col-impact">
             <span class="job-impact ${impactClass}">${impactDisplay}</span>
             <div class="job-impact-note small muted">Net total reflects estimated hours and material usage</div>
           </td>
           <td class="job-col job-col-actions">
             <div class="job-actions">
               <button data-log-job="${j.id}">Log time</button>
               <button data-edit-job="${j.id}">Edit</button>
               <button data-complete-job="${j.id}">Mark complete</button>
               <button class="danger" data-remove-job="${j.id}">Remove</button>
             </div>
@@ -1838,50 +2018,53 @@ function viewJobs(){
                   </div>
                 </div>
                 <div class="job-detail-files">
                   <span class="job-detail-label">Files</span>
                   ${fileLinks}
                 </div>
               </div>
             </div>
           </td>
         </tr>`;
     } else {
       // EDIT ROW
       return `
         <tr data-job-row="${j.id}" class="job-row editing">
           <td colspan="${activeColumnCount}">
               <div class="job-edit-card">
               <div class="job-edit-grid">
                 <label>Job name<input type="text" data-j="name" data-id="${j.id}" value="${j.name}"></label>
                 <label>Estimate (hrs)<input type="number" min="1" data-j="estimateHours" data-id="${j.id}" value="${j.estimateHours}"></label>
                 <label>Material<input type="text" data-j="material" data-id="${j.id}" value="${j.material||""}"></label>
                 <label>Material cost ($)<input type="number" min="0" step="0.01" data-j="materialCost" data-id="${j.id}" value="${matCost}"></label>
                 <label>Material quantity<input type="number" min="0" step="0.01" data-j="materialQty" data-id="${j.id}" value="${matQty}"></label>
                 <label>Charge rate ($/hr)<input type="number" min="0" step="0.01" data-j="chargeRate" data-id="${j.id}" value="${chargeRate}"></label>
                 <label>Start date<input type="date" data-j="startISO" data-id="${j.id}" value="${j.startISO||""}"></label>
                 <label>Due date<input type="date" data-j="dueISO" data-id="${j.id}" value="${dueVal}"></label>
+                <label>Category<select data-j="cat" data-id="${j.id}" data-job-category-select>
+                  ${categoryOptionsMarkup(j.cat, { includeCreateOption: true })}
+                </select></label>
               </div>
               <div class="job-edit-summary">
                 <div class="job-metric job-metric-total">
                   <span class="job-metric-label">Material total</span>
                   <span class="job-metric-value">$${matTotal.toFixed(2)}</span>
                 </div>
                 <div class="job-metric">
                   <span class="job-metric-label">Charge rate</span>
                   <span class="job-metric-value">${chargeDisplay}</span>
                 </div>
                 <div class="job-metric">
                   <span class="job-metric-label">Cost rate</span>
                   <span class="job-metric-value">${costDisplay}</span>
                 </div>
                 <div class="job-metric">
                   <span class="job-metric-label">Net profit / hr</span>
                   <span class="job-metric-value ${netClass}">${netDisplay}</span>
                 </div>
                 <div class="job-metric">
                   <span class="job-metric-label">Net total</span>
                   <span class="job-metric-value ${impactClass}">${netTotalDisplay}</span>
                 </div>
                 <div class="job-metric">
                   <span class="job-metric-label">Schedule</span>
                   <span class="job-metric-value small muted">${startTxt} → ${dueTxt}</span>
@@ -1889,95 +2072,114 @@ function viewJobs(){
               </div>
               <label class="job-edit-note">Notes<textarea data-j="notes" data-id="${j.id}" rows="3" placeholder="Notes...">${j.notes||""}</textarea></label>
               <div class="job-edit-files">
                 <button type="button" data-upload-job="${j.id}">Add Files</button>
                 <input type="file" data-job-file-input="${j.id}" multiple style="display:none">
                 <ul class="job-file-list">
                   ${jobFiles.length ? jobFiles.map((f, idx)=>{
                     const safeName = f.name || `file_${idx+1}`;
                     const href = f.dataUrl || f.url || "";
                     const link = href ? `<a href="${href}" download="${safeName}">${safeName}</a>` : safeName;
                     return `<li>${link} <button type="button" class="link" data-remove-file="${j.id}" data-file-index="${idx}">Remove</button></li>`;
                   }).join("") : `<li class=\"muted\">No files attached</li>`}
                 </ul>
               </div>
               <div class="job-edit-actions">
                 <button data-save-job="${j.id}">Save</button>
                 <button class="danger" data-cancel-job="${j.id}">Cancel</button>
               </div>
             </div>
           </td>
         </tr>`;
     }
   }).join("");
 
   return `
-  <div class="container">
-    <div class="block" style="grid-column:1 / -1">
+  <div class="container job-page-container">
+    <div class="block job-category-panel" data-job-category-panel>
+      <div class="job-category-header">
+        <h3>Job Categories</h3>
+        <button type="button" class="small" data-job-folder-add-root>+ Add Category</button>
+      </div>
+      <div class="job-category-tree">
+        ${folderTreeMarkup}
+      </div>
+      <p class="small muted">Select a category to focus the job list or create sub-categories to organize further.</p>
+    </div>
+    <div class="block job-main-block">
       <h3>Cutting Jobs</h3>
       <div class="job-page-toolbar">
+        <label class="job-category-filter">
+          <span>Show</span>
+          <select id="jobCategoryFilterSelect" aria-label="Filter cutting jobs by category">
+            ${categoryOptionsMarkup(selectedCategory)}
+          </select>
+        </label>
         <button type="button" class="job-history-button" data-job-history-trigger>Jump to history</button>
       </div>
       <form id="addJobForm" class="mini-form">
         <input type="text" id="jobName" placeholder="Job name" required>
         <input type="number" id="jobEst" placeholder="Estimate (hrs)" required min="1">
         <input type="number" id="jobCharge" placeholder="Charge rate ($/hr)" min="0" step="0.01">
         <input type="text" id="jobMaterial" placeholder="Material">
         <input type="number" id="jobMaterialCost" placeholder="Material cost ($)" min="0" step="0.01">
         <input type="number" id="jobMaterialQty" placeholder="Material quantity" min="0" step="0.01">
         <input type="date" id="jobStart" required>
         <input type="date" id="jobDue" required>
+        <select id="jobCategory" aria-label="Category" required>
+          ${categoryOptionsMarkup(selectedCategory, { includeCreateOption: true })}
+        </select>
         <button type="button" id="jobFilesBtn">Attach Files</button>
         <input type="file" id="jobFiles" multiple style="display:none">
         <button type="submit">Add Job</button>
       </form>
       <div class="small muted job-files-summary" id="jobFilesSummary">${pendingSummary}</div>
 
       <table class="job-table">
         <thead>
           <tr>
             <th>Job</th>
             <th>Estimate</th>
             <th>Material</th>
             <th>Cost / unit</th>
             <th>Quantity</th>
             <th>Material total</th>
             <th>Charge rate</th>
             <th>Cost rate</th>
             <th>Net profit/hr</th>
             <th>Hours remaining</th>
             <th>Needed / day</th>
             <th>Status</th>
             <th>Net total</th>
             <th>Actions</th>
           </tr>
         </thead>
         <tbody>${rows}</tbody>
       </table>
       <p class="small muted">Material cost and quantity update immediately when changed.</p>
     </div>
-    <div class="block past-jobs-block" id="pastJobs">
+    <div class="block past-jobs-block job-main-block" id="pastJobs">
       <h3>Past Cutting Jobs</h3>
       <div class="past-jobs-toolbar">
         <div class="past-jobs-search mini-form">
           <input type="search" id="jobHistorySearch" placeholder="Search past jobs by name, material, notes, or date" value="${historySearchDisplay}">
           <button type="button" id="jobHistorySearchClear">Clear</button>
         </div>
       </div>
       <div class="small muted past-jobs-hint">Results update as you type.</div>
       ${historyFilterStatus}
       ${completedTable}
     </div>
   </div>`;
 }
 
 function filterInventoryItems(term){
   const query = (term || "").trim().toLowerCase();
   if (!query) return inventory.slice();
   return inventory.filter(item => {
     const fields = [item.name, item.unit, item.pn, item.note, item.link];
     return fields.some(f => {
       if (f == null) return false;
       const text = String(f).toLowerCase();
       return text.includes(query);
     });
   });
 
EOF
)

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/js/renderers.js b/js/renderers.js
index 4d45d86a960f5e73946eb776666c162d31021426..e6d6ecbe754c0b0b6a1a0fccf8ff053fd36a761c 100644
--- a/js/renderers.js
+++ b/js/renderers.js
@@ -357,77 +357,79 @@ function captureNewJobFormState(){
     try {
       selectionStart = activeEl.selectionStart;
       selectionEnd = activeEl.selectionEnd;
       selectionDirection = activeEl.selectionDirection || null;
     } catch (_){
       selectionStart = selectionEnd = null;
       selectionDirection = null;
     }
     activeState = {
       id: activeEl.id,
       selectionStart,
       selectionEnd,
       selectionDirection
     };
   }
 
   return {
     fields: {
       name: captureField("jobName"),
       estimate: captureField("jobEst"),
       charge: captureField("jobCharge"),
       material: captureField("jobMaterial"),
       materialCost: captureField("jobMaterialCost"),
       materialQty: captureField("jobMaterialQty"),
       start: captureField("jobStart"),
-      due: captureField("jobDue")
+      due: captureField("jobDue"),
+      category: captureField("jobCategory")
     },
     active: activeState
   };
 }
 
 function restoreNewJobFormState(state){
   if (!state || typeof state !== "object" || !state.fields) return;
 
   const assignField = (id, value)=>{
     const el = document.getElementById(id);
     if (!el) return;
     try {
       el.value = value ?? "";
     } catch (_){
       // Ignore assignment issues for unsupported input types
     }
   };
 
   assignField("jobName", state.fields.name);
   assignField("jobEst", state.fields.estimate);
   assignField("jobCharge", state.fields.charge);
   assignField("jobMaterial", state.fields.material);
   assignField("jobMaterialCost", state.fields.materialCost);
   assignField("jobMaterialQty", state.fields.materialQty);
   assignField("jobStart", state.fields.start);
   assignField("jobDue", state.fields.due);
+  assignField("jobCategory", state.fields.category);
 
   if (state.active && state.active.id){
     const target = document.getElementById(state.active.id);
     if (target){
       try {
         target.focus({ preventScroll: true });
       } catch (_){
         try {
           target.focus();
         } catch (_){ }
       }
       const hasSelection = typeof state.active.selectionStart === "number"
         && typeof state.active.selectionEnd === "number";
       if (hasSelection){
         try {
           target.setSelectionRange(
             state.active.selectionStart,
             state.active.selectionEnd,
             state.active.selectionDirection || "none"
           );
         } catch (_){ }
       }
     }
   }
 }
@@ -2456,50 +2458,51 @@ function renderDashboard(){
   const taskLastInput    = document.getElementById("dashTaskLast");
   const taskConditionInput = document.getElementById("dashTaskCondition");
   const taskManualInput  = document.getElementById("dashTaskManual");
   const taskStoreInput   = document.getElementById("dashTaskStore");
   const taskPNInput      = document.getElementById("dashTaskPN");
   const taskPriceInput   = document.getElementById("dashTaskPrice");
   const categorySelect   = document.getElementById("dashTaskCategory");
   const taskDateInput    = document.getElementById("dashTaskDate");
   const subtaskList      = document.getElementById("dashSubtaskList");
   const addSubtaskBtn    = document.getElementById("dashAddSubtask");
   const taskOptionStage  = modal?.querySelector('[data-task-option-stage]');
   const taskOptionButtons= Array.from(modal?.querySelectorAll('[data-task-option]') || []);
   const taskExistingSearchInput = document.getElementById("dashTaskExistingSearch");
   const taskExistingSearchWrapper = taskExistingForm?.querySelector(".task-existing-search");
   const existingTaskSelect = document.getElementById("dashTaskExistingSelect");
   const existingTaskEmpty  = taskExistingForm?.querySelector('[data-task-existing-empty]');
   const existingTaskSearchEmpty = taskExistingForm?.querySelector('[data-task-existing-search-empty]');
   const jobNameInput     = document.getElementById("dashJobName");
   const jobEstimateInput = document.getElementById("dashJobEstimate");
   const jobChargeInput   = document.getElementById("dashJobCharge");
   const jobMaterialInput = document.getElementById("dashJobMaterial");
   const jobMaterialCostInput = document.getElementById("dashJobMaterialCost");
   const jobMaterialQtyInput = document.getElementById("dashJobMaterialQty");
   const jobStartInput    = document.getElementById("dashJobStart");
   const jobDueInput      = document.getElementById("dashJobDue");
+  const jobCategoryInput = document.getElementById("dashJobCategory");
   const garnetForm       = document.getElementById("dashGarnetForm");
   const garnetDateInput  = document.getElementById("dashGarnetDate");
   const garnetStartInput = document.getElementById("dashGarnetStart");
   const garnetEndInput   = document.getElementById("dashGarnetEnd");
   const garnetNoteInput  = document.getElementById("dashGarnetNote");
   const garnetSubmitBtn  = document.getElementById("dashGarnetSubmit");
   const garnetCancelBtn  = document.getElementById("dashGarnetCancel");
   const garnetList       = document.getElementById("dashGarnetList");
 
   const taskFreqRow      = taskForm?.querySelector("[data-task-frequency]");
   const taskLastRow      = taskForm?.querySelector("[data-task-last]");
   const taskConditionRow = taskForm?.querySelector("[data-task-condition]");
   const stepSections     = modal ? Array.from(modal.querySelectorAll("[data-step]")) : [];
   let addContextDateISO  = null;
   let editingGarnetId    = null;
   let pendingGarnetEditId = null;
 
   function findMaintenanceTaskById(id){
     if (id == null) return null;
     const lookup = String(id);
     let task = tasksInterval.find(item => item && String(item.id) === lookup);
     if (task) return { task, list: "interval" };
     task = tasksAsReq.find(item => item && String(item.id) === lookup);
     if (task) return { task, list: "asreq" };
     return null;
@@ -3427,64 +3430,100 @@ function renderDashboard(){
   downForm?.addEventListener("submit", (e)=>{
     e.preventDefault();
     const arr = ensureDownTimeArray();
     const dateISO = downDateInput?.value;
     if (!dateISO){ toast("Pick a date"); return; }
     if (arr.some(dt => dt.dateISO === dateISO)){ toast("Day already marked as down time"); return; }
     arr.push({ dateISO });
     arr.sort((a,b)=> String(a.dateISO).localeCompare(String(b.dateISO)));
     saveCloudDebounced();
     toast("Down time saved");
     if (downDateInput) downDateInput.value = "";
     refreshDownTimeList();
     renderCalendar();
   });
 
   jobForm?.addEventListener("submit", (e)=>{
     e.preventDefault();
     const name = (jobNameInput?.value || "").trim();
     const est  = Number(jobEstimateInput?.value);
     const chargeRaw = jobChargeInput?.value ?? "";
     const material = (jobMaterialInput?.value || "").trim();
     const materialCostRaw = jobMaterialCostInput?.value ?? "";
     const materialQtyRaw  = jobMaterialQtyInput?.value ?? "";
     const start = jobStartInput?.value;
     const due   = jobDueInput?.value;
+    let categoryId = jobCategoryInput?.value || "";
     const materialCost = materialCostRaw === "" ? 0 : Number(materialCostRaw);
     const materialQty  = materialQtyRaw === "" ? 0 : Number(materialQtyRaw);
     const chargeRate = chargeRaw === "" ? JOB_RATE_PER_HOUR : Number(chargeRaw);
     if (!name || !isFinite(est) || est <= 0 || !start || !due){ toast("Fill job fields."); return; }
     if (!Number.isFinite(materialCost) || materialCost < 0){ toast("Enter a valid material cost."); return; }
     if (!Number.isFinite(materialQty) || materialQty < 0){ toast("Enter a valid material quantity."); return; }
     if (!Number.isFinite(chargeRate) || chargeRate < 0){ toast("Enter a valid charge rate."); return; }
-    cuttingJobs.push({ id: genId(name), name, estimateHours: est, startISO: start, dueISO: due, material, materialCost, materialQty, chargeRate, notes:"", manualLogs:[] });
+    if (!categoryId){ toast("Choose a category."); return; }
+    if (categoryId === "__new__"){
+      const parent = window.jobCategoryFilter || (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root");
+      const folder = promptCreateCategory(parent);
+      if (!folder){ toast("Category not created."); return; }
+      categoryId = String(folder.id);
+      window.jobCategoryFilter = categoryId;
+    }
+    cuttingJobs.push({ id: genId(name), name, estimateHours: est, startISO: start, dueISO: due, material, materialCost, materialQty, chargeRate, notes:"", manualLogs:[], cat: categoryId });
+    ensureJobCategories?.();
     saveCloudDebounced();
     toast("Cutting job added");
     closeModal();
     renderDashboard();
   });
 
+  if (jobCategoryInput){
+    jobCategoryInput.dataset.prevValue = jobCategoryInput.value;
+    jobCategoryInput.addEventListener("focus", ()=>{ jobCategoryInput.dataset.prevValue = jobCategoryInput.value; });
+    jobCategoryInput.addEventListener("change", ()=>{
+      if (jobCategoryInput.value === "__new__"){
+        const parent = window.jobCategoryFilter || (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root");
+        const folder = promptCreateCategory(parent);
+        if (folder){
+          const newOption = document.createElement("option");
+          newOption.value = String(folder.id);
+          newOption.textContent = folder.name || "All Jobs";
+          const anchor = jobCategoryInput.querySelector('option[value="__new__"]');
+          jobCategoryInput.insertBefore(newOption, anchor);
+          jobCategoryInput.value = newOption.value;
+          jobCategoryInput.dataset.prevValue = newOption.value;
+          window.jobCategoryFilter = newOption.value;
+        }else{
+          const fallback = jobCategoryInput.dataset.prevValue || (window.jobCategoryFilter || (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root"));
+          jobCategoryInput.value = fallback;
+        }
+      }else{
+        jobCategoryInput.dataset.prevValue = jobCategoryInput.value;
+      }
+    });
+  }
+
   refreshDownTimeList();
 
   document.getElementById("calendarAddBtn")?.addEventListener("click", ()=> openModal("picker"));
   document.getElementById("calendarToggleBtn")?.addEventListener("click", (event)=>{
     toggleCalendarShowAllMonths();
     if (event?.currentTarget instanceof HTMLElement){
       event.currentTarget.blur();
     }
   });
 
   setupDashboardLayout();
   renderCalendar();
   setupCalendarHoursControls();
   setupTimeEfficiencyWidget(document.getElementById("dashboardTimeEfficiency"));
   renderPumpWidget();
   refreshTimeEfficiencyWidgets();
   notifyDashboardLayoutContentChanged();
 }
 
 function openJobsEditor(jobId){
   // Navigate to the Jobs page, then open the specified job in edit mode.
   // We wait briefly so the router can render the page before we toggle edit.
   location.hash = "#/jobs";
   setTimeout(()=>{
     // Mark this job as "editing" so viewJobs() renders the edit row
@@ -8425,50 +8464,55 @@ function drawCostChart(canvas, model, show){
         ? last.date.toLocaleDateString(undefined, { month: "short", day: "numeric", year: "numeric" })
         : "the latest update";
       let detail = (typeof last.detail === "string" && last.detail.trim()) ? last.detail.trim() : "";
       if (!detail){
         detail = series.key === "maintenance"
           ? `Estimated maintenance dollars allocated to hours logged on ${dateLabel}.`
           : `Rolling average profit per cutting job through ${dateLabel}.`;
       }
       hitTargets.push({
         key: series.key,
         datasetLabel,
         valueLabel,
         detail,
         rect: { x: boxX, y: boxY - boxHeight, width: boxWidth, height: boxHeight }
       });
     }
   });
 
   canvas.__costChartTargets = hitTargets;
 }
 
 
 function renderJobs(){
   const content = document.getElementById("content");
   if (!content) return;
+  try {
+    ensureJobCategories?.();
+  } catch (err){
+    console.warn("Failed to normalize job categories before render", err);
+  }
   setAppSettingsContext("default");
   wireDashboardSettingsMenu();
 
   // 1) Render the jobs view (includes the table with the Actions column)
   content.innerHTML = viewJobs();
 
   const focusPastJobs = ()=>{
     const target = document.getElementById("pastJobs");
     if (!target) return;
     const restoreTabindex = !target.hasAttribute("tabindex");
     if (restoreTabindex){
       target.setAttribute("tabindex", "-1");
       target.dataset.tempTabindex = "1";
     }
     target.scrollIntoView({ behavior: "smooth", block: "start" });
     try {
       target.focus({ preventScroll: true });
     } catch (_) {
       // Fallback focus handling for browsers without focus options
       target.focus();
     }
     if (restoreTabindex){
       const cleanup = ()=>{
         if (!target.dataset.tempTabindex) return;
         delete target.dataset.tempTabindex;
@@ -8484,50 +8528,142 @@ function renderJobs(){
     historyBtn.addEventListener("click", (event)=>{
       event.preventDefault();
       focusPastJobs();
     });
   }
 
   if (window.pendingJobHistoryFocus){
     delete window.pendingJobHistoryFocus;
     requestAnimationFrame(()=>{
       focusPastJobs();
     });
   }
 
   const historySearchInput = document.getElementById("jobHistorySearch");
   const historySearchClear = document.getElementById("jobHistorySearchClear");
 
   const captureScrollPosition = ()=> ({
     x: window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
     y: window.scrollY || document.documentElement.scrollTop || document.body.scrollTop || 0
   });
   const restoreScrollPosition = (pos)=>{
     if (!pos || typeof pos.x !== "number" || typeof pos.y !== "number") return;
     window.scrollTo(pos.x, pos.y);
   };
 
+  const rerenderPreservingState = (categoryId)=>{
+    const formState = captureNewJobFormState();
+    if (formState && formState.fields && categoryId){
+      formState.fields.category = categoryId;
+    }
+    const scrollPosition = captureScrollPosition();
+    renderJobs();
+    requestAnimationFrame(()=>{
+      restoreScrollPosition(scrollPosition);
+      restoreNewJobFormState(formState);
+    });
+  };
+
+  const ensureCategoryState = ()=>{
+    try {
+      return typeof ensureJobFolderState === "function" ? ensureJobFolderState() : (Array.isArray(window.jobFolders) ? window.jobFolders : []);
+    } catch (_){
+      return Array.isArray(window.jobFolders) ? window.jobFolders : [];
+    }
+  };
+
+  const promptCreateCategory = (parentId)=>{
+    const name = window.prompt("New category name?");
+    if (!name) return null;
+    try {
+      const folder = typeof addJobFolder === "function" ? addJobFolder(name, parentId) : null;
+      if (folder){
+        ensureJobCategories?.();
+        saveCloudDebounced();
+      }
+      return folder;
+    } catch (err){
+      console.warn("Failed to create job category", err);
+      toast("Unable to create category.");
+      return null;
+    }
+  };
+
+  const promptRenameCategory = (categoryId)=>{
+    if (!categoryId) return null;
+    const folder = ensureCategoryState().find(f => String(f.id) === String(categoryId));
+    if (!folder){ toast("Category not found"); return null; }
+    const next = window.prompt("Rename category", folder.name || "");
+    if (!next) return null;
+    try {
+      const result = typeof renameJobFolder === "function" ? renameJobFolder(categoryId, next) : null;
+      if (result){
+        saveCloudDebounced();
+      }
+      return result;
+    } catch (err){
+      console.warn("Failed to rename job category", err);
+      toast("Unable to rename category.");
+      return null;
+    }
+  };
+
+  const attemptRemoveCategory = (categoryId)=>{
+    if (!categoryId) return false;
+    const idStr = String(categoryId);
+    if (idStr === (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root")){
+      toast("Cannot remove the root category.");
+      return false;
+    }
+    const hasJobs = typeof jobFolderHasJobs === "function" ? jobFolderHasJobs(idStr) : false;
+    const hasChildren = ensureCategoryState().some(folder => String(folder.parent ?? "") === idStr);
+    if (hasJobs){ toast("Move jobs to another category before removing this one."); return false; }
+    if (hasChildren){ toast("Remove or move sub-categories first."); return false; }
+    const confirmed = typeof window.confirm === "function"
+      ? window.confirm("Remove this category?")
+      : true;
+    if (!confirmed) return false;
+    try {
+      const folder = ensureCategoryState().find(f => String(f.id) === idStr);
+      if (folder && typeof recordDeletedItem === "function"){
+        try {
+          recordDeletedItem("job-folder", folder, { parent: folder.parent ?? null });
+        } catch (err){ console.warn("Failed to record deleted job folder", err); }
+      }
+      const removed = typeof removeJobFolder === "function" ? removeJobFolder(idStr) : false;
+      if (removed){
+        ensureJobCategories?.();
+        saveCloudDebounced();
+        return true;
+      }
+    } catch (err){
+      console.warn("Failed to remove job category", err);
+    }
+    toast("Unable to remove category.");
+    return false;
+  };
+
   if (historySearchInput){
     historySearchInput.addEventListener("input", (event)=>{
       jobHistorySearchTerm = event.target.value;
       window.jobHistorySearchTerm = jobHistorySearchTerm;
       const selectionStart = event.target.selectionStart ?? jobHistorySearchTerm.length;
       const selectionEnd = event.target.selectionEnd ?? selectionStart;
       const selectionDirection = event.target.selectionDirection || "none";
       const scrollPosition = captureScrollPosition();
       renderJobs();
       requestAnimationFrame(()=>{
         restoreScrollPosition(scrollPosition);
         const nextInput = document.getElementById("jobHistorySearch");
         if (!nextInput) return;
         try {
           nextInput.focus({ preventScroll: true });
         } catch (_){
           nextInput.focus();
         }
         try {
           const start = Math.min(selectionStart, nextInput.value.length);
           const end = Math.min(selectionEnd, nextInput.value.length);
           nextInput.setSelectionRange(start, end, selectionDirection);
         } catch (_){ }
       });
     });
@@ -8553,50 +8689,208 @@ function renderJobs(){
           nextInput.setSelectionRange(0, 0);
         } catch (_){ }
       });
     });
   }
 
   const newFilesBtn = document.getElementById("jobFilesBtn");
   const newFilesInput = document.getElementById("jobFiles");
   newFilesBtn?.addEventListener("click", ()=>{ newFilesInput?.click(); });
   newFilesInput?.addEventListener("change", async (e)=>{
     const files = e.target.files;
     if (!files || !files.length) return;
     const formState = captureNewJobFormState();
     const attachments = await filesToAttachments(files);
     e.target.value = "";
     if (!attachments.length){
       restoreNewJobFormState(formState);
       return;
     }
     pendingNewJobFiles.push(...attachments.map(a=>({ ...a })));
     toast(`${attachments.length} file${attachments.length===1?"":"s"} added`);
     renderJobs();
     restoreNewJobFormState(formState);
   });
 
+  const addRootCategoryBtn = content.querySelector("[data-job-folder-add-root]");
+  addRootCategoryBtn?.addEventListener("click", ()=>{
+    const folder = promptCreateCategory(typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root");
+    if (folder){
+      window.jobCategoryFilter = String(folder.id);
+      rerenderPreservingState(String(folder.id));
+    }
+  });
+
+  if (!content.dataset.jobFolderEvents){
+    content.dataset.jobFolderEvents = "1";
+    content.addEventListener("click", (event)=>{
+      const addBtn = event.target.closest("[data-job-folder-add]");
+      if (addBtn){
+        event.preventDefault();
+        const parentId = addBtn.getAttribute("data-job-folder-add");
+        const folder = promptCreateCategory(parentId);
+        if (folder){
+          window.jobCategoryFilter = String(folder.id);
+          rerenderPreservingState(String(folder.id));
+        }
+        return;
+      }
+      const renameBtn = event.target.closest("[data-job-folder-rename]");
+      if (renameBtn){
+        event.preventDefault();
+        const catId = renameBtn.getAttribute("data-job-folder-rename");
+        const result = promptRenameCategory(catId);
+        if (result){
+          rerenderPreservingState(String(catId));
+        }
+        return;
+      }
+      const removeBtn = event.target.closest("[data-job-folder-remove]");
+      if (removeBtn){
+        event.preventDefault();
+        const catId = removeBtn.getAttribute("data-job-folder-remove");
+        if (attemptRemoveCategory(catId)){
+          const current = String(window.jobCategoryFilter || "");
+          if (current === String(catId)){ window.jobCategoryFilter = typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root"; }
+          rerenderPreservingState(window.jobCategoryFilter);
+        }
+        return;
+      }
+      const selectBtn = event.target.closest("[data-job-folder-select]");
+      if (selectBtn){
+        event.preventDefault();
+        const id = selectBtn.getAttribute("data-job-folder-select");
+        if (id){
+          window.jobCategoryFilter = String(id);
+          rerenderPreservingState(String(id));
+        }
+      }
+    });
+  }
+
+  const jobCategorySelect = document.getElementById("jobCategory");
+  if (jobCategorySelect){
+    jobCategorySelect.dataset.prevValue = jobCategorySelect.value;
+    jobCategorySelect.addEventListener("focus", ()=>{ jobCategorySelect.dataset.prevValue = jobCategorySelect.value; });
+    jobCategorySelect.addEventListener("change", (event)=>{
+      const select = event.target;
+      if (!select) return;
+      if (select.value === "__new__"){
+        const parent = window.jobCategoryFilter || (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root");
+        const folder = promptCreateCategory(parent);
+        if (folder){
+          select.value = String(folder.id);
+          select.dataset.prevValue = String(folder.id);
+          window.jobCategoryFilter = String(folder.id);
+          rerenderPreservingState(String(folder.id));
+        }else{
+          const fallback = select.dataset.prevValue || (window.jobCategoryFilter || (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root"));
+          select.value = fallback;
+        }
+      }else{
+        select.dataset.prevValue = select.value;
+      }
+    });
+  }
+
+  const jobCategoryFilterSelect = document.getElementById("jobCategoryFilterSelect");
+  if (jobCategoryFilterSelect){
+    jobCategoryFilterSelect.addEventListener("change", (event)=>{
+      const rawValue = event?.target instanceof HTMLSelectElement ? event.target.value : jobCategoryFilterSelect.value;
+      const rootId = typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root";
+      const folders = ensureCategoryState();
+      const validIds = new Set(folders.map(folder => String(folder?.id)));
+      const nextId = validIds.has(String(rawValue)) ? String(rawValue) : rootId;
+      window.jobCategoryFilter = nextId;
+      jobCategoryFilterSelect.value = nextId;
+      rerenderPreservingState(nextId);
+    });
+  }
+
+  content.querySelectorAll("[data-job-category-select]").forEach(select => {
+    if (!(select instanceof HTMLSelectElement)) return;
+    if (select.dataset.wiredCategory) return;
+    select.dataset.wiredCategory = "1";
+    select.dataset.prevValue = select.value;
+    select.addEventListener("focus", ()=>{ select.dataset.prevValue = select.value; });
+  });
+
+  if (!content.dataset.jobCategorySelectEvents){
+    content.dataset.jobCategorySelectEvents = "1";
+    content.addEventListener("change", (event)=>{
+      const select = event.target.closest("[data-job-category-select]");
+      if (!(select instanceof HTMLSelectElement)) return;
+      const inlineIdRaw = select.getAttribute("data-job-category-inline");
+      const inlineId = inlineIdRaw != null ? String(inlineIdRaw) : "";
+      const isInline = inlineId.length > 0;
+      const rootId = typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root";
+      const previousValue = select.dataset.prevValue || (isInline ? String(select.value || rootId) : select.value || "");
+
+      if (select.value === "__new__"){
+        const parent = window.jobCategoryFilter || rootId;
+        const folder = promptCreateCategory(parent);
+        if (folder){
+          const nextId = String(folder.id);
+          select.value = nextId;
+          select.dataset.prevValue = nextId;
+          if (isInline){
+            const job = cuttingJobs.find(j => String(j?.id) === inlineId);
+            if (job){
+              job.cat = nextId;
+              ensureJobCategories?.();
+              saveCloudDebounced();
+            }
+          }
+          window.jobCategoryFilter = nextId;
+          rerenderPreservingState(nextId);
+        }else{
+          const fallback = previousValue || (window.jobCategoryFilter || rootId);
+          select.value = fallback;
+        }
+        return;
+      }
+
+      const nextSelection = String(select.value || rootId);
+      select.dataset.prevValue = nextSelection;
+
+      if (isInline){
+        const job = cuttingJobs.find(j => String(j?.id) === inlineId);
+        if (!job){
+          const fallback = previousValue || (window.jobCategoryFilter || rootId);
+          select.value = fallback;
+          select.dataset.prevValue = fallback;
+          return;
+        }
+        job.cat = nextSelection;
+        ensureJobCategories?.();
+        saveCloudDebounced();
+        const currentFilter = typeof window.jobCategoryFilter === "string" ? window.jobCategoryFilter : rootId;
+        rerenderPreservingState(currentFilter);
+      }
+    });
+  }
+
   // 2) Small, scoped helpers for manual log math + defaults
   const todayISO = (()=>{ const d=new Date(); d.setHours(0,0,0,0); return d.toISOString().slice(0,10); })();
   const curTotal = ()=> (RENDER_TOTAL ?? currentTotal());
 
   function getHoursAt(dateISO){
     // Machine totalHours reading at or before dateISO
     if (!Array.isArray(totalHistory) || !totalHistory.length) return null;
     const target = new Date(dateISO + "T00:00:00");
     let best = null;
     for (const h of totalHistory){
       const d = new Date(h.dateISO + "T00:00:00");
       if (d <= target){ if (best==null || d > new Date(best.dateISO+"T00:00:00")) best = h; }
     }
     return best ? Number(best.hours) : null;
   }
   function lastManual(job){
     if (!job || !Array.isArray(job.manualLogs) || job.manualLogs.length===0) return null;
     const logs = job.manualLogs.slice().sort((a,b)=> a.dateISO.localeCompare(b.dateISO));
     return logs[logs.length-1];
   }
   function machineSinceStart(job){
     if (!job?.startISO) return 0;
     const startH = getHoursAt(job.startISO);
     const nowH   = curTotal();
     if (startH==null || nowH==null) return 0;
@@ -8604,59 +8898,70 @@ function renderJobs(){
   }
   function suggestSpent(job){
     // Suggest “spent since last manual” using 8 hrs/day; if no manual, 0
     const lm = lastManual(job);
     if (lm){
       const last = new Date(lm.dateISO + "T00:00:00");
       const today = new Date(todayISO + "T00:00:00");
       const days = Math.max(0, Math.floor((today - last)/(24*60*60*1000)));
       return days * DAILY_HOURS;
     }
     return 0;
   }
   const clamp = (v,min,max)=> Math.max(min, Math.min(max, v));
 
   // 4) Add Job (unchanged)
   document.getElementById("addJobForm")?.addEventListener("submit",(e)=>{
     e.preventDefault();
     const name  = document.getElementById("jobName").value.trim();
     const est   = Number(document.getElementById("jobEst").value);
     const material = document.getElementById("jobMaterial")?.value.trim() || "";
     const chargeRaw = document.getElementById("jobCharge")?.value ?? "";
     const materialCostRaw = document.getElementById("jobMaterialCost")?.value ?? "";
     const materialQtyRaw = document.getElementById("jobMaterialQty")?.value ?? "";
     const start = document.getElementById("jobStart").value;
     const due   = document.getElementById("jobDue").value;
+    const categorySelect = document.getElementById("jobCategory");
+    let categoryId = categorySelect?.value || "";
     const materialCost = materialCostRaw === "" ? 0 : Number(materialCostRaw);
     const materialQty = materialQtyRaw === "" ? 0 : Number(materialQtyRaw);
     const chargeRate = chargeRaw === "" ? JOB_RATE_PER_HOUR : Number(chargeRaw);
     if (!name || !isFinite(est) || est<=0 || !start || !due){ toast("Fill job fields."); return; }
     if (!Number.isFinite(materialCost) || materialCost < 0){ toast("Enter a valid material cost."); return; }
     if (!Number.isFinite(materialQty) || materialQty < 0){ toast("Enter a valid material quantity."); return; }
     if (!Number.isFinite(chargeRate) || chargeRate < 0){ toast("Enter a valid charge rate."); return; }
+    if (!categoryId){ toast("Choose a category."); return; }
+    if (categoryId === "__new__"){
+      const parent = window.jobCategoryFilter || (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root");
+      const folder = promptCreateCategory(parent);
+      if (!folder){ toast("Category not created."); return; }
+      categoryId = String(folder.id);
+      window.jobCategoryFilter = categoryId;
+    }
     const attachments = pendingNewJobFiles.map(f=>({ ...f }));
-    cuttingJobs.push({ id: genId(name), name, estimateHours:est, startISO:start, dueISO:due, material, materialCost, materialQty, chargeRate, notes:"", manualLogs:[], files:attachments });
+    cuttingJobs.push({ id: genId(name), name, estimateHours:est, startISO:start, dueISO:due, material, materialCost, materialQty, chargeRate, notes:"", manualLogs:[], files:attachments, cat: categoryId });
+    ensureJobCategories?.();
     pendingNewJobFiles.length = 0;
     saveCloudDebounced(); renderJobs();
   });
 
   // 5) Inline material $/qty (kept)
   content.querySelector("tbody")?.addEventListener("change", async (e)=>{
     if (e.target.matches("input[data-job-file-input]")){
       const id = e.target.getAttribute("data-job-file-input");
       const j = cuttingJobs.find(x=>x.id===id);
       if (!j){ e.target.value = ""; return; }
       const attachments = await filesToAttachments(e.target.files);
       e.target.value = "";
       if (!attachments.length) return;
       j.files = Array.isArray(j.files) ? j.files : [];
       attachments.forEach(att=> j.files.push({ ...att }));
       saveCloudDebounced();
       toast(`${attachments.length} file${attachments.length===1?"":"s"} added`);
       renderJobs();
     }
   });
 
   const historyBody = content.querySelector(".past-jobs-table tbody");
   historyBody?.addEventListener("click", async (e)=>{
     const histEdit = e.target.closest("[data-history-edit]");
     const histCancel = e.target.closest("[data-history-cancel]");
@@ -8740,51 +9045,52 @@ function renderJobs(){
       const startDate = parseJobDate(startISO);
       const dueDate = parseJobDate(dueISO);
       if (!startDate || !dueDate){ toast("Enter valid dates."); return; }
       const normalizedDays = Math.max(1, Math.round((dueDate.getTime() - startDate.getTime()) / JOB_DAY_MS) + 1);
 
       let estimateHours = Number(entry.estimateHours);
       const materialCost = Number(entry.materialCost);
       const materialQty = Number(entry.materialQty);
       if (!Number.isFinite(estimateHours) || estimateHours <= 0){
         estimateHours = normalizedDays * hoursPerDay;
       }
       const newJob = {
         id: genId(entry.name || "job"),
         name: entry.name || "Cutting job",
         estimateHours,
         startISO,
         dueISO,
         material: entry.material || "",
         materialCost: Number.isFinite(materialCost) ? materialCost : 0,
         materialQty: Number.isFinite(materialQty) ? materialQty : 0,
         chargeRate: Number.isFinite(Number(entry.chargeRate)) && Number(entry.chargeRate) >= 0
           ? Number(entry.chargeRate)
           : JOB_RATE_PER_HOUR,
         notes: entry.notes || "",
         manualLogs: [],
-        files: Array.isArray(entry.files) ? entry.files.map(f => ({ ...f })) : []
+        files: Array.isArray(entry.files) ? entry.files.map(f => ({ ...f })) : [],
+        cat: entry.cat != null ? entry.cat : (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root")
       };
 
       cuttingJobs.push(newJob);
       window.cuttingJobs = cuttingJobs;
       saveCloudDebounced();
       toast("Active cutting job created");
       renderJobs();
       return;
     }
 
     if (histEdit){
       const id = histEdit.getAttribute("data-history-edit");
       if (id != null){ editingCompletedJobsSet().add(String(id)); renderJobs(); }
       return;
     }
 
     if (histCancel){
       const id = histCancel.getAttribute("data-history-cancel");
       if (id != null){ editingCompletedJobsSet().delete(String(id)); renderJobs(); }
       return;
     }
 
     if (histDelete){
       const id = histDelete.getAttribute("data-history-delete");
       if (!id) return;
@@ -8802,86 +9108,90 @@ function renderJobs(){
         }
       }
       completedCuttingJobs = completedCuttingJobs.filter(job => String(job?.id) !== idStr);
       window.completedCuttingJobs = completedCuttingJobs;
       editingCompletedJobsSet().delete(idStr);
       saveCloudDebounced();
       toast("History entry deleted");
       renderJobs();
       return;
     }
 
     if (histSave){
       const id = histSave.getAttribute("data-history-save");
       if (!id) return;
       const entry = completedCuttingJobs.find(job => String(job?.id) === String(id));
       if (!entry) return;
       const field = (key)=> content.querySelector(`[data-history-field="${key}"][data-history-id="${id}"]`);
       const nameInput = field("name");
       const estimateInput = field("estimateHours");
       const actualInput = field("actualHours");
       const materialInput = field("material");
       const materialCostInput = field("materialCost");
       const materialQtyInput = field("materialQty");
       const notesInput = field("notes");
       const completedInput = field("completedAtISO");
+      const categoryInput = field("cat");
 
       const name = (nameInput?.value || entry.name || "").trim();
       if (!name){ toast("Enter a job name."); return; }
 
       const estVal = estimateInput?.value;
       const estNum = estVal === "" || estVal == null ? null : Number(estVal);
       const estimateHours = Number.isFinite(estNum) && estNum >= 0 ? estNum : Number(entry.estimateHours) || 0;
 
       const actVal = actualInput?.value;
       const actualNum = actVal === "" || actVal == null ? null : Number(actVal);
       const actualHours = Number.isFinite(actualNum) && actualNum >= 0 ? actualNum : null;
 
       const material = materialInput?.value ?? entry.material ?? "";
       const materialCostVal = materialCostInput?.value;
       const materialCostNum = materialCostVal === "" || materialCostVal == null ? null : Number(materialCostVal);
       const materialCost = Number.isFinite(materialCostNum) && materialCostNum >= 0 ? materialCostNum : Number(entry.materialCost) || 0;
 
       const materialQtyVal = materialQtyInput?.value;
       const materialQtyNum = materialQtyVal === "" || materialQtyVal == null ? null : Number(materialQtyVal);
       const materialQty = Number.isFinite(materialQtyNum) && materialQtyNum >= 0 ? materialQtyNum : Number(entry.materialQty) || 0;
 
       const notes = notesInput?.value ?? entry.notes ?? "";
 
       const completedRaw = completedInput?.value;
       if (completedRaw){
         const dt = new Date(completedRaw);
         if (!Number.isNaN(dt.getTime())) entry.completedAtISO = dt.toISOString();
       }
 
       entry.name = name;
       entry.estimateHours = estimateHours;
       entry.material = material;
       entry.materialCost = materialCost;
       entry.materialQty = materialQty;
       entry.notes = notes;
       entry.actualHours = actualHours != null ? actualHours : null;
+      if (categoryInput && categoryInput.value && categoryInput.value !== "__new__"){
+        entry.cat = categoryInput.value;
+      }
 
       const rate = Number(entry.efficiency?.rate) || JOB_RATE_PER_HOUR;
       const deltaHours = actualHours != null ? (estimateHours - actualHours) : (entry.efficiency?.deltaHours ?? null);
       const gainLoss = deltaHours != null ? deltaHours * rate : (entry.efficiency?.gainLoss ?? null);
 
       entry.efficiency = {
         ...entry.efficiency,
         rate,
         expectedHours: estimateHours,
         actualHours: entry.actualHours,
         expectedRemaining: 0,
         actualRemaining: 0,
         deltaHours,
         gainLoss
       };
 
       editingCompletedJobsSet().delete(String(id));
       saveCloudDebounced();
       toast("History updated");
       renderJobs();
     }
   });
 
   // 6) Edit/Remove/Save/Cancel + Log panel + Apply spent/remaining
   content.querySelector("tbody")?.addEventListener("click",(e)=>{
@@ -8973,84 +9283,87 @@ function renderJobs(){
         netRate: null,
         expectedHours: null,
         actualHours: null,
         expectedRemaining: null,
         actualRemaining: null,
         deltaHours: null,
         gainLoss: null
       };
 
       const completed = {
         id: job.id,
         name: job.name,
         estimateHours: job.estimateHours,
         startISO: job.startISO,
         dueISO: job.dueISO,
         completedAtISO: completionISO,
         notes: job.notes || "",
         material: job.material || "",
         materialCost: Number(job.materialCost)||0,
         materialQty: Number(job.materialQty)||0,
         chargeRate: Number.isFinite(Number(job.chargeRate)) && Number(job.chargeRate) >= 0
           ? Number(job.chargeRate)
           : JOB_RATE_PER_HOUR,
         manualLogs: Array.isArray(job.manualLogs) ? job.manualLogs.slice() : [],
         files: Array.isArray(job.files) ? job.files.map(f=>({ ...f })) : [],
+        cat: job.cat != null ? job.cat : (typeof window.JOB_ROOT_FOLDER_ID === "string" ? window.JOB_ROOT_FOLDER_ID : "jobs_root"),
         actualHours: eff && Number.isFinite(eff.actualHours) ? eff.actualHours : null,
         efficiency: efficiencySummary
       };
 
       completedCuttingJobs.push(completed);
       cuttingJobs.splice(idx, 1);
       editingJobs.delete(id);
       saveCloudDebounced();
       toast("Job marked complete");
       renderJobs();
       return;
     }
 
     // Save (from edit row)
     if (sv){
       const id = sv.getAttribute("data-save-job");
       const j  = cuttingJobs.find(x=>x.id===id); if (!j) return;
       const qs = (k)=> content.querySelector(`[data-j="${k}"][data-id="${id}"]`)?.value;
       const chargeRaw = qs("chargeRate");
       const chargeVal = chargeRaw === "" || chargeRaw == null ? null : Number(chargeRaw);
       if (chargeVal != null && (!Number.isFinite(chargeVal) || chargeVal < 0)){ toast("Enter a valid charge rate."); return; }
       const existingCharge = Number.isFinite(Number(j.chargeRate)) && Number(j.chargeRate) >= 0
         ? Number(j.chargeRate)
         : JOB_RATE_PER_HOUR;
       const chargeToSet = chargeVal == null ? existingCharge : chargeVal;
+      const catVal = qs("cat");
       j.name = qs("name") || j.name;
       j.estimateHours = Math.max(1, Number(qs("estimateHours"))||j.estimateHours||1);
       j.material = qs("material") || j.material || "";
       j.materialCost = Math.max(0, Number(qs("materialCost")) || 0);
       j.materialQty = Math.max(0, Number(qs("materialQty")) || 0);
       j.startISO = qs("startISO") || j.startISO;
       j.dueISO   = qs("dueISO")   || j.dueISO;
       j.notes    = content.querySelector(`[data-j="notes"][data-id="${id}"]`)?.value || j.notes || "";
       j.chargeRate = chargeToSet;
+      if (catVal && catVal !== "__new__") j.cat = catVal;
       editingJobs.delete(id);
       saveCloudDebounced(); renderJobs();
       return;
     }
 
     // Cancel edit
     if (ca){ editingJobs.delete(ca.getAttribute("data-cancel-job")); renderJobs(); return; }
 
     // Toggle inline Log panel (adds both "spent" and "remaining" controls)
     if (lg){
       const id = lg.getAttribute("data-log-job");
       const anchor   = content.querySelector(`tr[data-job-row="${id}"]`);
       const existing = content.querySelector(`tr[data-log-row="${id}"]`);
       if (existing){ existing.remove(); return; }
       if (!anchor) return;
 
       const j  = cuttingJobs.find(x=>x.id===id); if (!j) return;
       const lm = lastManual(j);
       const spentSuggest = suggestSpent(j);
       const completedSoFar = lm ? Number(lm.completedHours)||0 : 0;
       const machineInitNote = (!lm && machineSinceStart(j)>0)
         ? `<div class="muted small">Prefilled uses <strong>machine hours since start</strong> when available.</div>` : ``;
 
       const trForm = document.createElement("tr");
       trForm.className = "manual-log-row";
 
EOF
)v

 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/js/core.js b/js/core.js
index ff6f7f1c45c820187726f411a09a20d1de9fb3b2..535e91ad48ae55fd939602a2a88cb2913ba6a073 100644
--- a/js/core.js
+++ b/js/core.js
@@ -1,39 +1,39 @@
 /* =========================================================
    OMAX 1530 Maintenance Tracker — v7.1 (Regenerated)
    - Firestore cloud sync (email/password modal; shared workspace doc)
    - 3-month calendar + hover bubbles
    - Hours log → Δ distribution for maintenance intervals
    - Cutting Jobs with efficiency model + required/day
    - Pump Efficiency widget (baseline + daily RPM logs + chart)
    - Settings + Costs (incl. materials) + lightweight Inventory
    - Route-based rendering
    - Minimal CSS injection (if stylesheet is missing)
    ========================================================= */
 
 /* =================== CONSTANTS / GLOBALS =================== */
-const APP_SCHEMA = 71;
+const APP_SCHEMA = 72;
 const DAILY_HOURS = 8;
 const JOB_RATE_PER_HOUR = 250; // $/hr (default charge when a job doesn't set its own rate)
 const JOB_BASE_COST_PER_HOUR = 30; // $/hr baseline internal cost applied to every job
 const WORKSPACE_ID = "schreiner-robotics";
 const CUTTING_BASELINE_WEEKLY_HOURS = 56;
 const CUTTING_BASELINE_DAILY_HOURS = CUTTING_BASELINE_WEEKLY_HOURS / 7;
 const TIME_EFFICIENCY_WINDOWS = [
   { key: "7d", label: "1W", days: 7, description: "Past 7 days" },
   { key: "30d", label: "1M", days: 30, description: "Past 30 days" },
   { key: "90d", label: "3M", days: 90, description: "Past 3 months" },
   { key: "182d", label: "6M", days: 182, description: "Past 6 months" },
   { key: "365d", label: "1Y", days: 365, description: "Past year" }
 ];
 
 const CLEAR_DATA_PASSWORD = (typeof window !== "undefined" && typeof window.CLEAR_DATA_PASSWORD === "string" && window.CLEAR_DATA_PASSWORD)
   ? window.CLEAR_DATA_PASSWORD
   : "reset-omax";
 if (typeof window !== "undefined") window.CLEAR_DATA_PASSWORD = CLEAR_DATA_PASSWORD;
 
 window.APP_SCHEMA = APP_SCHEMA;
 
 if (typeof window !== "undefined"){
   window.cloudDashboardLayout = {};
   window.cloudCostLayout = {};
   window.cloudDashboardLayoutLoaded = false;
@@ -353,111 +353,50 @@ const defaultIntervalTasks = [
   { id:"ro_softener_daily_chk", name:"RO / Softener feed pressure & water quality — daily", interval:8, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"mixing_tube_rotation",  name:"Mixing tube rotation", interval:8, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"jewel_nozzle_clean",    name:"Jewell orifice & nozzle body cleaning (weekly)", interval:56, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"check_bonding_strap",   name:"Check hopper bonding strap (annually)", interval:2920, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"lube_z_axis",           name:"Lubricate Z-axis rail shafts & lead screw (annually)", interval:2920, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"filter_housing_or_2y",  name:"Filter housing O-ring (2 years / if leaking)", interval:5840, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", pn:"208665", price:4.85, completedDates: [] }
 ];
 const defaultAsReqTasks = [
   { id:"purge_hopper_pressure_pot", name:"Purge hopper pressure pot", condition:"As required", manualLink:"", storeLink:"" },
   { id:"replace_pot_sensors",       name:"Replace pressure pot sensors", condition:"When failed", manualLink:"", storeLink:"" },
   { id:"empty_hopper_abrasive",     name:"Empty hopper abrasive material", condition:"If debris/contamination", manualLink:"", storeLink:"" },
 
   { id:"replace_pinch_valve", name:"Replace hopper pinch valve", condition:"When damaged", manualLink:"", storeLink:"", pn:"204160", price:292 },
   { id:"replace_feed_hose",   name:"Replace abrasive feed hose", condition:"When damaged", manualLink:"", storeLink:"", pn:"302240", price:121 },
   { id:"ro_filter_housing",   name:"RO Filter Housing",          condition:"As needed",   manualLink:"", storeLink:"", pn:"208663", price:137 },
   { id:"ro_micron_filter",    name:"RO Micron filter",           condition:"Per water quality/pressure", manualLink:"", storeLink:"", pn:"209260-01", price:35.5 },
   { id:"ro_carbon_filter",    name:"RO Carbon filter",           condition:"Per chlorine breakthrough",  manualLink:"", storeLink:"", pn:"204365", price:25 },
   { id:"ro_calcite_filter",   name:"RO Calcite filter",          condition:"Per water quality / pH",     manualLink:"", storeLink:"", pn:"204876", price:72 },
 
   { id:"inspect_abrasive_tube", name:"Abrasive tubing inspection", condition:"Before each use", manualLink:"", storeLink:"" },
   { id:"clean_xy_strips",       name:"Clean X– & Y–axis magnetic encoder strips", condition:"If errors occur", manualLink:"", storeLink:"" },
   { id:"clean_lube_ballscrews", name:"Clean & lubricate ball screws", condition:"If debris occurs", manualLink:"", storeLink:"" },
   { id:"clean_rails",           name:"Clean X-rails & Y-bridge rails", condition:"If debris occurs", manualLink:"", storeLink:"" }
 ];
 
-/* ===================== Persisted state ===================== */
-if (!Array.isArray(window.totalHistory)) window.totalHistory = [];   // [{dateISO, hours}]
-if (!Array.isArray(window.tasksInterval)) window.tasksInterval = [];
-if (!Array.isArray(window.tasksAsReq))   window.tasksAsReq   = [];
-if (!Array.isArray(window.inventory))    window.inventory    = [];
-if (!Array.isArray(window.cuttingJobs))  window.cuttingJobs  = [];   // [{id,name,estimateHours,material,materialCost,materialQty,chargeRate,notes,startISO,dueISO,manualLogs:[{dateISO,completedHours}],files:[{name,dataUrl,type,size,addedAt}]}]
-if (!Array.isArray(window.completedCuttingJobs)) window.completedCuttingJobs = [];
-if (!Array.isArray(window.pendingNewJobFiles)) window.pendingNewJobFiles = [];
-if (!Array.isArray(window.orderRequests)) window.orderRequests = [];
-if (!Array.isArray(window.garnetCleanings)) window.garnetCleanings = [];
-if (!Array.isArray(window.dailyCutHours)) window.dailyCutHours = [];
-if (typeof window.orderRequestTab !== "string") window.orderRequestTab = "active";
-
-if (typeof window.pumpEff !== "object" || !window.pumpEff){
-  window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] };
-}
-if (!Array.isArray(window.pumpEff.entries)) window.pumpEff.entries = [];
-if (!Array.isArray(window.pumpEff.notes)) window.pumpEff.notes = [];
-
-let totalHistory = window.totalHistory;
-let tasksInterval = window.tasksInterval;
-let tasksAsReq    = window.tasksAsReq;
-let inventory     = window.inventory;
-let cuttingJobs   = window.cuttingJobs;
-let completedCuttingJobs = window.completedCuttingJobs;
-let orderRequests = window.orderRequests;
-let orderRequestTab = window.orderRequestTab;
-let garnetCleanings = window.garnetCleanings;
-let dailyCutHours = window.dailyCutHours;
-
-function refreshGlobalCollections(){
-  if (typeof window === "undefined") return;
-
-  if (!Array.isArray(window.totalHistory)) window.totalHistory = [];
-  totalHistory = window.totalHistory;
-
-  if (!Array.isArray(window.tasksInterval)) window.tasksInterval = [];
-  tasksInterval = window.tasksInterval;
-
-  if (!Array.isArray(window.tasksAsReq)) window.tasksAsReq = [];
-  tasksAsReq = window.tasksAsReq;
-
-  if (!Array.isArray(window.inventory)) window.inventory = [];
-  inventory = window.inventory;
-
-  if (!Array.isArray(window.cuttingJobs)) window.cuttingJobs = [];
-  cuttingJobs = window.cuttingJobs;
-
-  if (!Array.isArray(window.completedCuttingJobs)) window.completedCuttingJobs = [];
-  completedCuttingJobs = window.completedCuttingJobs;
-
-  if (!Array.isArray(window.orderRequests)) window.orderRequests = [];
-  orderRequests = window.orderRequests;
-
-  if (!Array.isArray(window.garnetCleanings)) window.garnetCleanings = [];
-  garnetCleanings = window.garnetCleanings;
-
-  if (!Array.isArray(window.dailyCutHours)) window.dailyCutHours = [];
-  dailyCutHours = window.dailyCutHours;
-}
-
 function resolveTaskVariant(task){
   if (!task || typeof task !== "object") return null;
   const raw = typeof task.variant === "string" ? task.variant.toLowerCase() : "";
   if (raw === "template" || raw === "instance") return raw;
   if (task.templateId != null && String(task.templateId) !== String(task.id)) return "instance";
   return null;
 }
 
 function isTemplateTask(task){
   const variant = resolveTaskVariant(task);
   if (variant) return variant === "template";
   return !!(task && (task.mode === "interval" || task.mode === "asreq"));
 }
 
 function isInstanceTask(task){
   return resolveTaskVariant(task) === "instance";
 }
 
 function ensureTaskVariant(task, type){
   if (!task || typeof task !== "object") return;
   const variant = resolveTaskVariant(task);
   if (variant === "template" || variant === "instance") return;
   if (type === "interval" || type === "asreq"){
     task.variant = "template";
   }
@@ -819,50 +758,76 @@ function applyRestoreByType(entry, index){
       completedCuttingJobs.push(clone);
       window.completedCuttingJobs = completedCuttingJobs;
       return { handledRemoval: false, value: { type: "completed-job", id: clone.id } };
     }
     case "folder": {
       window.settingsFolders = Array.isArray(window.settingsFolders) ? window.settingsFolders : [];
       const existing = new Set(window.settingsFolders.map(f => String(f.id)));
       if (!clone.id) clone.id = genId(clone.name || "folder");
       while (existing.has(String(clone.id))){
         clone.id = genId(clone.name || "folder");
       }
       if (typeof window._maintOrderCounter !== "number" || !Number.isFinite(window._maintOrderCounter)){
         window._maintOrderCounter = 0;
       }
       const orderVal = Number(clone.order);
       if (Number.isFinite(orderVal)){
         if (orderVal > window._maintOrderCounter) window._maintOrderCounter = orderVal;
       } else {
         clone.order = ++window._maintOrderCounter;
       }
       window.settingsFolders.push(clone);
       try { setSettingsFolders(window.settingsFolders); }
       catch (err) { console.warn("Failed to normalize folders after restore", err); }
       return { handledRemoval: false, value: { type: "folder", id: clone.id } };
     }
+    case "job-folder": {
+      const folders = ensureJobFolderState();
+      const existing = new Set(folders.map(f => String(f.id)));
+      if (!clone.id) clone.id = genId(clone.name || "category");
+      while (existing.has(String(clone.id))){
+        clone.id = genId(clone.name || "category");
+      }
+      if (typeof window._jobFolderOrderCounter !== "number" || !Number.isFinite(window._jobFolderOrderCounter)){
+        window._jobFolderOrderCounter = 0;
+      }
+      const orderVal = Number(clone.order);
+      if (Number.isFinite(orderVal)){
+        if (orderVal > window._jobFolderOrderCounter) window._jobFolderOrderCounter = orderVal;
+      } else {
+        clone.order = ++window._jobFolderOrderCounter;
+      }
+      folders.push({
+        id: clone.id,
+        name: typeof clone.name === "string" ? clone.name : "",
+        parent: clone.parent == null ? JOB_ROOT_FOLDER_ID : String(clone.parent),
+        order: clone.order
+      });
+      setJobFolders(folders);
+      ensureJobCategories();
+      return { handledRemoval: false, value: { type: "job-folder", id: clone.id } };
+    }
     case "garnet": {
       if (!Array.isArray(garnetCleanings)) garnetCleanings = [];
       if (!clone.id) clone.id = genId("garnet");
       const existing = new Set(garnetCleanings.filter(Boolean).map(item => String(item.id)));
       while (existing.has(String(clone.id))){
         clone.id = genId("garnet");
       }
       garnetCleanings.push(clone);
       garnetCleanings.sort((a, b)=> String(a.dateISO || "").localeCompare(String(b.dateISO || "")));
       window.garnetCleanings = garnetCleanings;
       return { handledRemoval: false, value: { type: "garnet", id: clone.id } };
     }
     case "order-item": {
       if (!Array.isArray(orderRequests)) orderRequests = [];
       let request = null;
       if (meta && meta.requestId){
         request = orderRequests.find(req => req && req.id === meta.requestId);
       }
       if (!request){
         try { request = ensureActiveOrderRequest(); }
         catch (_){ request = null; }
       }
       if (!request){
         const created = createOrderRequest();
         orderRequests.push(created);
@@ -930,78 +895,69 @@ function restoreDeletedItem(id){
 
 function snapshotWorkspaceForTrash(){
   const snap = snapshotState();
   snap.deletedItems = [];
   return snap;
 }
 
 function recordDeletedItem(type, payload, meta){
   return addDeletedItem(type, payload, meta);
 }
 
 if (typeof window !== "undefined"){
   window.listDeletedItems = listDeletedItems;
   window.recordDeletedItem = recordDeletedItem;
   window.restoreDeletedItem = restoreDeletedItem;
   window.removeDeletedItem = removeDeletedItem;
   window.purgeExpiredDeletedItems = purgeExpiredDeletedItems;
 }
 
 if (typeof window.deletedItemsSearchTerm !== "string") window.deletedItemsSearchTerm = "";
 if (typeof window.inventorySearchTerm !== "string") window.inventorySearchTerm = "";
 let inventorySearchTerm = window.inventorySearchTerm;
 if (typeof window.jobHistorySearchTerm !== "string") window.jobHistorySearchTerm = "";
 let jobHistorySearchTerm = window.jobHistorySearchTerm;
 
-/* ================ Jobs editing & render flags ================ */
-if (!(window.editingJobs instanceof Set)) window.editingJobs = new Set();
-if (!(window.editingCompletedJobs instanceof Set)) window.editingCompletedJobs = new Set();
-if (typeof window.RENDER_TOTAL !== "number") window.RENDER_TOTAL = null;
-if (typeof window.RENDER_DELTA !== "number") window.RENDER_DELTA = 0;
-
-const editingJobs  = window.editingJobs;
-let   RENDER_TOTAL = window.RENDER_TOTAL;
-let   RENDER_DELTA = window.RENDER_DELTA;
-
-function getEditingCompletedJobsSet(){
-  if (!(window.editingCompletedJobs instanceof Set)){
-    window.editingCompletedJobs = new Set();
-  }
-  return window.editingCompletedJobs;
-}
-
-window.getEditingCompletedJobsSet = getEditingCompletedJobsSet;
-
 window.defaultIntervalTasks = defaultIntervalTasks;
 const ROOT_FOLDER_ID = "root";
 window.ROOT_FOLDER_ID = ROOT_FOLDER_ID;
 const DEFAULT_SETTINGS_FOLDERS = [
   { id: ROOT_FOLDER_ID, name: "All Tasks",    parent: null,           order: 3 },
   { id: "interval",    name: "Per Interval", parent: ROOT_FOLDER_ID, order: 2 },
   { id: "asreq",       name: "As Required",  parent: ROOT_FOLDER_ID, order: 1 }
 ];
 
+const JOB_ROOT_FOLDER_ID = "jobs_root";
+window.JOB_ROOT_FOLDER_ID = JOB_ROOT_FOLDER_ID;
+const DEFAULT_JOB_FOLDERS = [
+  { id: JOB_ROOT_FOLDER_ID, name: "All Jobs", parent: null, order: 1 }
+];
+
+function defaultJobFolders(){
+  return DEFAULT_JOB_FOLDERS.map(f => ({ ...f }));
+}
+
 function defaultSettingsFolders(){
   return DEFAULT_SETTINGS_FOLDERS.map(f => ({ ...f }));
 }
 
 function normalizeSettingsFolders(raw){
   const seen = new Set();
   const normalized = [];
   if (Array.isArray(raw)){
     for (const entry of raw){
       if (!entry || entry.id == null) continue;
       const key = String(entry.id);
       if (seen.has(key)) continue;
       seen.add(key);
       const rawParent = entry.parent != null ? entry.parent : null;
       let parent = null;
       if (key === ROOT_FOLDER_ID){
         parent = null;
       }else if (rawParent == null || String(rawParent) === "" || String(rawParent) === key){
         parent = ROOT_FOLDER_ID;
       }else{
         parent = rawParent;
       }
       normalized.push({
         id: entry.id,
         name: typeof entry.name === "string" ? entry.name : "",
@@ -1017,50 +973,204 @@ function normalizeSettingsFolders(raw){
       if (existing){
         if (!existing.name) existing.name = template.name;
         if (existing.parent == null && template.parent != null) existing.parent = template.parent;
         if (!Number.isFinite(existing.order) && Number.isFinite(template.order)){
           existing.order = Number(template.order);
         }
         if (key !== ROOT_FOLDER_ID && (existing.parent == null || String(existing.parent) === "")){
           existing.parent = template.parent ?? ROOT_FOLDER_ID;
         }
       }
       continue;
     }
     seen.add(key);
     normalized.push({ ...template });
   }
   return normalized;
 }
 
 function setSettingsFolders(raw){
   const normalized = normalizeSettingsFolders(raw);
   window.settingsFolders = normalized;
   window.folders = cloneFolders(window.settingsFolders);
   return window.settingsFolders;
 }
 
+function cloneJobFolders(list){
+  if (!Array.isArray(list)) return [];
+  return list.map(folder => ({ ...folder }));
+}
+
+function normalizeJobFolders(raw){
+  const seen = new Set();
+  const normalized = [];
+  if (Array.isArray(raw)){
+    for (const entry of raw){
+      if (!entry || entry.id == null) continue;
+      const id = String(entry.id);
+      if (seen.has(id)) continue;
+      seen.add(id);
+      const rawParent = entry.parent != null ? entry.parent : null;
+      let parent = null;
+      if (id === JOB_ROOT_FOLDER_ID){
+        parent = null;
+      }else if (rawParent == null || String(rawParent) === "" || String(rawParent) === id){
+        parent = JOB_ROOT_FOLDER_ID;
+      }else{
+        parent = String(rawParent);
+      }
+      const name = typeof entry.name === "string" ? entry.name : "";
+      const order = Number.isFinite(entry.order) ? Number(entry.order) : 0;
+      normalized.push({ id, name, parent, order });
+    }
+  }
+
+  if (!seen.has(JOB_ROOT_FOLDER_ID)){
+    normalized.push({ ...DEFAULT_JOB_FOLDERS[0] });
+  }
+
+  const validIds = new Set(normalized.map(folder => String(folder.id)));
+  normalized.forEach(folder => {
+    if (String(folder.id) === JOB_ROOT_FOLDER_ID){
+      folder.parent = null;
+      return;
+    }
+    if (!validIds.has(String(folder.parent))){
+      folder.parent = JOB_ROOT_FOLDER_ID;
+    }
+  });
+
+  return normalized;
+}
+
+function setJobFolders(raw){
+  const normalized = normalizeJobFolders(raw);
+  window.jobFolders = normalized;
+  if (typeof window._jobFolderOrderCounter !== "number" || !Number.isFinite(window._jobFolderOrderCounter)){
+    window._jobFolderOrderCounter = 0;
+  }
+  for (const folder of normalized){
+    const orderVal = Number(folder?.order);
+    if (Number.isFinite(orderVal) && orderVal > window._jobFolderOrderCounter){
+      window._jobFolderOrderCounter = orderVal;
+    }
+  }
+  return window.jobFolders;
+}
+
+function snapshotJobFolders(){
+  const source = Array.isArray(window.jobFolders) ? window.jobFolders : defaultJobFolders();
+  const normalized = normalizeJobFolders(source);
+  window.jobFolders = normalized;
+  return cloneJobFolders(normalized);
+}
+
+/* ===================== Persisted state ===================== */
+if (!Array.isArray(window.totalHistory)) window.totalHistory = [];   // [{dateISO, hours}]
+if (!Array.isArray(window.tasksInterval)) window.tasksInterval = [];
+if (!Array.isArray(window.tasksAsReq))   window.tasksAsReq   = [];
+if (!Array.isArray(window.inventory))    window.inventory    = [];
+if (!Array.isArray(window.cuttingJobs))  window.cuttingJobs  = [];   // [{id,name,estimateHours,material,materialCost,materialQty,chargeRate,notes,startISO,dueISO,manualLogs:[{dateISO,completedHours}],files:[{name,dataUrl,type,size,addedAt}]}]
+if (!Array.isArray(window.completedCuttingJobs)) window.completedCuttingJobs = [];
+if (!Array.isArray(window.pendingNewJobFiles)) window.pendingNewJobFiles = [];
+if (!Array.isArray(window.orderRequests)) window.orderRequests = [];
+if (!Array.isArray(window.garnetCleanings)) window.garnetCleanings = [];
+if (!Array.isArray(window.dailyCutHours)) window.dailyCutHours = [];
+if (!Array.isArray(window.jobFolders)) window.jobFolders = defaultJobFolders();
+if (typeof window.orderRequestTab !== "string") window.orderRequestTab = "active";
+
+if (typeof window.pumpEff !== "object" || !window.pumpEff){
+  window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] };
+}
+if (!Array.isArray(window.pumpEff.entries)) window.pumpEff.entries = [];
+if (!Array.isArray(window.pumpEff.notes)) window.pumpEff.notes = [];
+
+let totalHistory = window.totalHistory;
+let tasksInterval = window.tasksInterval;
+let tasksAsReq    = window.tasksAsReq;
+let inventory     = window.inventory;
+let cuttingJobs   = window.cuttingJobs;
+let completedCuttingJobs = window.completedCuttingJobs;
+let orderRequests = window.orderRequests;
+let orderRequestTab = window.orderRequestTab;
+let garnetCleanings = window.garnetCleanings;
+let dailyCutHours = window.dailyCutHours;
+let jobFolders = window.jobFolders;
+
+function refreshGlobalCollections(){
+  if (typeof window === "undefined") return;
+
+  if (!Array.isArray(window.totalHistory)) window.totalHistory = [];
+  totalHistory = window.totalHistory;
+
+  if (!Array.isArray(window.tasksInterval)) window.tasksInterval = [];
+  tasksInterval = window.tasksInterval;
+
+  if (!Array.isArray(window.tasksAsReq)) window.tasksAsReq = [];
+  tasksAsReq = window.tasksAsReq;
+
+  if (!Array.isArray(window.inventory)) window.inventory = [];
+  inventory = window.inventory;
+
+  if (!Array.isArray(window.cuttingJobs)) window.cuttingJobs = [];
+  cuttingJobs = window.cuttingJobs;
+
+  if (!Array.isArray(window.completedCuttingJobs)) window.completedCuttingJobs = [];
+  completedCuttingJobs = window.completedCuttingJobs;
+
+  if (!Array.isArray(window.orderRequests)) window.orderRequests = [];
+  orderRequests = window.orderRequests;
+
+  if (!Array.isArray(window.garnetCleanings)) window.garnetCleanings = [];
+  garnetCleanings = window.garnetCleanings;
+
+  if (!Array.isArray(window.dailyCutHours)) window.dailyCutHours = [];
+  dailyCutHours = window.dailyCutHours;
+
+  if (!Array.isArray(window.jobFolders)) window.jobFolders = defaultJobFolders();
+  jobFolders = window.jobFolders;
+}
+
+/* ================ Jobs editing & render flags ================ */
+if (!(window.editingJobs instanceof Set)) window.editingJobs = new Set();
+if (!(window.editingCompletedJobs instanceof Set)) window.editingCompletedJobs = new Set();
+if (typeof window.RENDER_TOTAL !== "number") window.RENDER_TOTAL = null;
+if (typeof window.RENDER_DELTA !== "number") window.RENDER_DELTA = 0;
+
+const editingJobs  = window.editingJobs;
+let   RENDER_TOTAL = window.RENDER_TOTAL;
+let   RENDER_DELTA = window.RENDER_DELTA;
+
+function getEditingCompletedJobsSet(){
+  if (!(window.editingCompletedJobs instanceof Set)){
+    window.editingCompletedJobs = new Set();
+  }
+  return window.editingCompletedJobs;
+}
+
+window.getEditingCompletedJobsSet = getEditingCompletedJobsSet;
+
 function cloneFolders(list){
   if (!Array.isArray(list)) return [];
   return list.map(folder => ({ ...folder }));
 }
 
 function foldersEqual(a, b){
   if (!Array.isArray(a) || !Array.isArray(b)) return false;
   if (a.length !== b.length) return false;
 
   const normalizeEntry = (folder)=>(
     {
       id: folder && folder.id != null ? String(folder.id) : "",
       name: typeof folder?.name === "string" ? folder.name : "",
       parent: folder && folder.parent != null ? String(folder.parent) : null,
       order: Number.isFinite(Number(folder?.order)) ? Number(folder.order) : 0
     }
   );
 
   const map = new Map();
   for (const entry of a){
     const norm = normalizeEntry(entry);
     if (!norm.id) continue;
     map.set(norm.id, norm);
   }
 
@@ -1105,50 +1215,51 @@ function snapshotState(){
   }));
   const dashLayoutSource = window.cloudDashboardLayoutLoaded
     ? window.cloudDashboardLayout
     : (window.dashboardLayoutState && window.dashboardLayoutState.layoutById);
   const costLayoutSource = window.cloudCostLayoutLoaded
     ? window.cloudCostLayout
     : (window.costLayoutState && window.costLayoutState.layoutById);
   return {
     schema: window.APP_SCHEMA || APP_SCHEMA,
     totalHistory,
     tasksInterval,
     tasksAsReq,
     inventory,
     cuttingJobs,
     completedCuttingJobs,
     orderRequests,
     orderRequestTab,
     garnetCleanings,
     dailyCutHours: Array.isArray(dailyCutHours)
       ? dailyCutHours.map(entry => ({ ...entry }))
       : [],
     pumpEff: safePumpEff,
     deletedItems: trashSnapshot,
     settingsFolders: foldersSnapshot,
     folders: cloneFolders(window.settingsFolders),
+    jobFolders: snapshotJobFolders(),
     dashboardLayout: cloneStructured(dashLayoutSource) || {},
     costLayout: cloneStructured(costLayoutSource) || {}
   };
 }
 
 /* ======================== HISTORY ========================= */
 const HISTORY_LIMIT = 50;
 const undoStack = [];
 const redoStack = [];
 let currentSnapshotJSON = null;
 let suppressHistory = false;
 let skipNextHistoryCapture = false;
 
 function syncRenderTotalsFromHistory(){
   const len = Array.isArray(totalHistory) ? totalHistory.length : 0;
   const last = len ? totalHistory[len - 1] : null;
   const prev = len > 1 ? totalHistory[len - 2] : null;
 
   const curHours = last != null ? Number(last.hours) : NaN;
   const prevHours = prev != null ? Number(prev.hours) : NaN;
 
   const cur = Number.isFinite(curHours) ? curHours : null;
   const prevVal = Number.isFinite(prevHours) ? prevHours : null;
   const delta = (cur != null && prevVal != null) ? Math.max(0, cur - prevVal) : null;
 
@@ -1263,50 +1374,141 @@ setSettingsFolders(window.settingsFolders || window.folders);
 /* ================ Explorer helper functions ================= */
 function childrenFolders(parentId){
   const key = String(parentId ?? "");
   const folders = Array.isArray(window.settingsFolders) ? window.settingsFolders : [];
   return folders.filter(f => String((f?.parent ?? "")) === key);
 }
 
 function topTasksInCat(folderId){
   switch (folderId) {
     case "interval": return tasksInterval;
     case "asreq":    return tasksAsReq;
     default:         return tasksInterval.concat(tasksAsReq);
   }
 }
 
 /* Ensure every task carries a category tag used by calendar/explorer */
 function ensureTaskCategories(){
   tasksInterval.forEach(t => {
     if (!t) return;
     if (!t.cat) t.cat = "interval";
     if (!Array.isArray(t.completedDates)) t.completedDates = [];
   });
   tasksAsReq.forEach(t =>    { if (t && !t.cat) t.cat = "asreq"; });
 }
 
+function ensureJobCategories(){
+  const folders = Array.isArray(window.jobFolders) ? window.jobFolders : defaultJobFolders();
+  const rootId = folders.find(f => String(f.id) === JOB_ROOT_FOLDER_ID)
+    ? JOB_ROOT_FOLDER_ID
+    : (folders[0] ? String(folders[0].id) : JOB_ROOT_FOLDER_ID);
+  const validIds = new Set(folders.map(f => String(f.id)));
+  const normalize = (cat)=>{
+    const key = cat != null ? String(cat) : rootId;
+    return validIds.has(key) ? key : rootId;
+  };
+  cuttingJobs.forEach(job => {
+    if (!job) return;
+    job.cat = normalize(job.cat);
+  });
+  completedCuttingJobs.forEach(job => {
+    if (!job) return;
+    job.cat = normalize(job.cat);
+  });
+}
+
+function ensureJobFolderState(){
+  if (!Array.isArray(window.jobFolders)) window.jobFolders = defaultJobFolders();
+  setJobFolders(window.jobFolders);
+  return window.jobFolders;
+}
+
+function jobFolderChildren(parentId){
+  const folders = ensureJobFolderState();
+  const key = parentId == null ? null : String(parentId);
+  return folders.filter(folder => {
+    const parentKey = folder.parent == null ? null : String(folder.parent);
+    return parentKey === key;
+  });
+}
+
+function addJobFolder(name, parentId){
+  const folders = ensureJobFolderState();
+  const label = (name || "").trim();
+  const parentKey = parentId != null ? String(parentId) : JOB_ROOT_FOLDER_ID;
+  const fallbackParent = folders.some(folder => String(folder.id) === parentKey)
+    ? parentKey
+    : JOB_ROOT_FOLDER_ID;
+  const orderBase = folders.reduce((max, folder)=>{
+    const val = Number(folder?.order);
+    return Number.isFinite(val) && val > max ? val : max;
+  }, (typeof window._jobFolderOrderCounter === "number" && Number.isFinite(window._jobFolderOrderCounter)) ? window._jobFolderOrderCounter : 0);
+  const id = genId(label || "category");
+  const folder = {
+    id,
+    name: label,
+    parent: fallbackParent === JOB_ROOT_FOLDER_ID ? JOB_ROOT_FOLDER_ID : fallbackParent,
+    order: orderBase + 1
+  };
+  folders.push(folder);
+  setJobFolders(folders);
+  ensureJobCategories();
+  return folder;
+}
+
+function renameJobFolder(id, name){
+  if (id == null) return null;
+  const folders = ensureJobFolderState();
+  const key = String(id);
+  const target = folders.find(folder => String(folder.id) === key);
+  if (!target) return null;
+  target.name = (name || "").trim();
+  setJobFolders(folders);
+  return target;
+}
+
+function removeJobFolder(id){
+  if (id == null) return false;
+  const folders = ensureJobFolderState();
+  const key = String(id);
+  if (key === JOB_ROOT_FOLDER_ID) return false;
+  const hasChildren = folders.some(folder => String(folder.parent ?? "") === key);
+  if (hasChildren) return false;
+  const remaining = folders.filter(folder => String(folder.id) !== key);
+  if (remaining.length === folders.length) return false;
+  window.jobFolders = remaining;
+  setJobFolders(window.jobFolders);
+  ensureJobCategories();
+  return true;
+}
+
+function jobFolderHasJobs(id){
+  const key = id != null ? String(id) : JOB_ROOT_FOLDER_ID;
+  return cuttingJobs.some(job => String(job?.cat ?? "") === key)
+    || completedCuttingJobs.some(job => String(job?.cat ?? "") === key);
+}
+
 function normalizeInventoryItem(raw){
   if (!raw || typeof raw !== "object") return null;
   const item = { ...raw };
   const newVal = Number(item.qtyNew);
   const oldVal = Number(item.qtyOld);
   const legacyVal = Number(item.qty);
   let qtyNew = Number.isFinite(newVal) && newVal >= 0 ? newVal : null;
   let qtyOld = Number.isFinite(oldVal) && oldVal >= 0 ? oldVal : null;
   if (qtyNew == null){
     qtyNew = Number.isFinite(legacyVal) && legacyVal >= 0 ? legacyVal : 0;
   }
   if (qtyOld == null){
     qtyOld = 0;
   }
   item.qtyNew = qtyNew;
   item.qtyOld = qtyOld;
   item.qty = qtyNew + qtyOld;
   if (!item.unit){ item.unit = "pcs"; }
   return item;
 }
 
 function normalizeDailyCutHours(list){
   const map = new Map();
   if (Array.isArray(list)){
     list.forEach(raw => {
@@ -1427,50 +1629,56 @@ function adoptState(doc){
   window.inventory = inventory;
   window.cuttingJobs = cuttingJobs;
   window.completedCuttingJobs = completedCuttingJobs;
   window.orderRequests = orderRequests;
   window.garnetCleanings = garnetCleanings;
   window.dailyCutHours = dailyCutHours;
   deletedItems = normalizeDeletedItems(Array.isArray(data.deletedItems) ? data.deletedItems : deletedItems);
   window.deletedItems = deletedItems;
   purgeExpiredDeletedItems();
   if (!Array.isArray(window.pendingNewJobFiles)) window.pendingNewJobFiles = [];
   window.pendingNewJobFiles.length = 0;
   if (typeof data.orderRequestTab === "string"){
     orderRequestTab = data.orderRequestTab;
     window.orderRequestTab = orderRequestTab;
   }
   if (typeof window.orderRequestTab !== "string" || !window.orderRequestTab){
     window.orderRequestTab = orderRequestTab || "active";
   }
   orderRequestTab = window.orderRequestTab;
 
   const rawFolders = Array.isArray(data.settingsFolders)
     ? data.settingsFolders
     : (Array.isArray(data.folders) ? data.folders : null);
   setSettingsFolders(rawFolders);
 
+  const rawJobFolders = Array.isArray(data.jobFolders)
+    ? data.jobFolders
+    : null;
+  setJobFolders(rawJobFolders);
+  jobFolders = window.jobFolders;
+
   const docDashboardLayout = (data.dashboardLayout && typeof data.dashboardLayout === "object")
     ? data.dashboardLayout
     : {};
   const docCostLayout = (data.costLayout && typeof data.costLayout === "object")
     ? data.costLayout
     : {};
 
   if (typeof window !== "undefined"){
     window.cloudDashboardLayout = cloneStructured(docDashboardLayout) || {};
     window.cloudDashboardLayoutLoaded = true;
     window.cloudCostLayout = cloneStructured(docCostLayout) || {};
     window.cloudCostLayoutLoaded = true;
   }
 
   try {
     if (typeof window.localStorage !== "undefined" && window.localStorage){
       const storage = window.localStorage;
       const dashKeys = Object.keys(window.cloudDashboardLayout || {});
       if (dashKeys.length){
         storage.setItem("dashboard_layout_windows_v1", JSON.stringify(window.cloudDashboardLayout));
       } else {
         storage.removeItem("dashboard_layout_windows_v1");
       }
       const costKeys = Object.keys(window.cloudCostLayout || {});
       if (costKeys.length){
@@ -1526,96 +1734,98 @@ function adoptState(doc){
       const val = Number(task && task.order);
       if (Number.isFinite(val) && val > maxOrder) maxOrder = val;
     }
   }
   for (const folder of window.settingsFolders){
     const val = Number(folder && folder.order);
     if (Number.isFinite(val) && val > maxOrder) maxOrder = val;
   }
   window._maintOrderCounter = maxOrder;
 
   // Pump efficiency (guard against reading an undefined identifier)
   const pe = (typeof window.pumpEff === "object" && window.pumpEff)
     ? window.pumpEff
     : (window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] });
   if (!Array.isArray(pe.entries)) pe.entries = [];
   if (!Array.isArray(pe.notes)) pe.notes = [];
 
   if (data.pumpEff && typeof data.pumpEff === "object"){
     pe.baselineRPM     = (data.pumpEff.baselineRPM ?? pe.baselineRPM);
     pe.baselineDateISO = (data.pumpEff.baselineDateISO ?? pe.baselineDateISO);
     pe.entries         = Array.isArray(data.pumpEff.entries) ? data.pumpEff.entries.slice() : pe.entries;
     pe.notes           = Array.isArray(data.pumpEff.notes) ? data.pumpEff.notes.slice() : pe.notes;
   }
 
   ensureTaskCategories();
+  ensureJobCategories();
   syncRenderTotalsFromHistory();
 }
 
 
 const saveCloudInternal = debounce(async ()=>{
   if (!FB.ready || !FB.docRef) return;
   try{ await FB.docRef.set(snapshotState(), { merge:true }); }catch(e){ console.error("Cloud save failed:", e); }
 }, 300);
 function saveCloudDebounced(){
   try {
     setSettingsFolders(window.settingsFolders);
   } catch (err) {
     console.warn("Failed to normalize folders before save:", err);
   }
   captureHistorySnapshot();
   saveCloudInternal();
 }
 async function loadFromCloud(){
   if (!FB.ready || !FB.docRef) return;
   try{
     const snap = await FB.docRef.get();
     if (snap.exists){
       const data = snap.data() || {};
       const needsSeed = !Array.isArray(data.tasksInterval) || data.tasksInterval.length === 0;
       if (needsSeed){
         const pe = (typeof window.pumpEff === "object" && window.pumpEff)
           ? window.pumpEff
           : (window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] });
         if (!Array.isArray(pe.entries)) pe.entries = [];
         if (!Array.isArray(pe.notes)) pe.notes = [];
         const seededFolders = normalizeSettingsFolders(data.settingsFolders || data.folders);
         const seededFoldersPayload = cloneFolders(seededFolders);
         const seeded = {
           schema:APP_SCHEMA,
           totalHistory: Array.isArray(data.totalHistory) ? data.totalHistory : [],
           tasksInterval: defaultIntervalTasks.slice(),
           tasksAsReq: Array.isArray(data.tasksAsReq) && data.tasksAsReq.length ? data.tasksAsReq : defaultAsReqTasks.slice(),
           inventory: Array.isArray(data.inventory) && data.inventory.length ? data.inventory : seedInventoryFromTasks(),
           cuttingJobs: Array.isArray(data.cuttingJobs) ? data.cuttingJobs : [],
           completedCuttingJobs: Array.isArray(data.completedCuttingJobs) ? data.completedCuttingJobs : [],
           garnetCleanings: Array.isArray(data.garnetCleanings) ? data.garnetCleanings : [],
           orderRequests: Array.isArray(data.orderRequests) ? normalizeOrderRequests(data.orderRequests) : [createOrderRequest()],
           orderRequestTab: typeof data.orderRequestTab === "string" ? data.orderRequestTab : "active",
           dailyCutHours: Array.isArray(data.dailyCutHours) ? normalizeDailyCutHours(data.dailyCutHours) : [],
           settingsFolders: seededFoldersPayload,
           folders: cloneFolders(seededFoldersPayload),
+          jobFolders: defaultJobFolders(),
           pumpEff: pe,
           deletedItems: normalizeDeletedItems(data.deletedItems || data.deleted_items || []),
           dashboardLayout: cloneStructured(data.dashboardLayout && typeof data.dashboardLayout === "object" ? data.dashboardLayout : {}) || {},
           costLayout: cloneStructured(data.costLayout && typeof data.costLayout === "object" ? data.costLayout : {}) || {}
         };
         adoptState(seeded);
         resetHistoryToCurrent();
         await FB.docRef.set(seeded, { merge:true });
       }else{
         const docHasSettingsFolders = Array.isArray(data.settingsFolders);
         const docHasLegacyFolders = Array.isArray(data.folders);
         const docFoldersRaw = docHasSettingsFolders
           ? data.settingsFolders
           : (docHasLegacyFolders ? data.folders : null);
         const normalizedDocFolders = normalizeSettingsFolders(docFoldersRaw);
 
         adoptState(data);
         resetHistoryToCurrent();
 
         const localFoldersSnapshot = cloneFolders(window.settingsFolders);
         let shouldSyncFolders = !docHasSettingsFolders || !docHasLegacyFolders;
         if (!shouldSyncFolders){
           shouldSyncFolders = !foldersEqual(normalizedDocFolders, localFoldersSnapshot);
         }
 
@@ -1627,71 +1837,72 @@ async function loadFromCloud(){
               folders: cloneFolders(payloadFolders)
             }, { merge:true });
           } catch (err) {
             console.warn("Failed to sync folders to cloud:", err);
           }
         }
       }
     }else{
       const pe = (typeof window.pumpEff === "object" && window.pumpEff)
         ? window.pumpEff
         : (window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] });
       if (!Array.isArray(pe.entries)) pe.entries = [];
       if (!Array.isArray(pe.notes)) pe.notes = [];
       const defaultFolders = defaultSettingsFolders();
       const seeded = {
         schema: APP_SCHEMA,
         totalHistory: [],
         tasksInterval: defaultIntervalTasks.slice(),
         tasksAsReq: defaultAsReqTasks.slice(),
         inventory: seedInventoryFromTasks(),
         cuttingJobs: [],
         completedCuttingJobs: [],
         orderRequests: [createOrderRequest()],
         orderRequestTab: "active",
         dailyCutHours: [],
+        jobFolders: defaultJobFolders(),
         pumpEff: pe,
         settingsFolders: defaultFolders,
         folders: cloneFolders(defaultFolders),
         garnetCleanings: [],
         deletedItems: [],
         dashboardLayout: {},
         costLayout: {}
       };
       adoptState(seeded);
       resetHistoryToCurrent();
       await FB.docRef.set(seeded);
     }
   }catch(e){
     console.error("Cloud load failed:", e);
     const pe = (typeof window.pumpEff === "object" && window.pumpEff)
       ? window.pumpEff
       : (window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] });
     if (!Array.isArray(pe.entries)) pe.entries = [];
     if (!Array.isArray(pe.notes)) pe.notes = [];
     const fallbackFolders = defaultSettingsFolders();
-    adoptState({ schema:APP_SCHEMA, totalHistory:[], tasksInterval:defaultIntervalTasks.slice(), tasksAsReq:defaultAsReqTasks.slice(), inventory:seedInventoryFromTasks(), cuttingJobs:[], completedCuttingJobs:[], orderRequests:[createOrderRequest()], orderRequestTab:"active", dailyCutHours: [], pumpEff: pe, settingsFolders: fallbackFolders, folders: cloneFolders(fallbackFolders), garnetCleanings: [], deletedItems: [], dashboardLayout: {}, costLayout: {} });
+    adoptState({ schema:APP_SCHEMA, totalHistory:[], tasksInterval:defaultIntervalTasks.slice(), tasksAsReq:defaultAsReqTasks.slice(), inventory:seedInventoryFromTasks(), cuttingJobs:[], completedCuttingJobs:[], orderRequests:[createOrderRequest()], orderRequestTab:"active", dailyCutHours: [], jobFolders: defaultJobFolders(), pumpEff: pe, settingsFolders: fallbackFolders, folders: cloneFolders(fallbackFolders), garnetCleanings: [], deletedItems: [], dashboardLayout: {}, costLayout: {} });
     resetHistoryToCurrent();
   }
 }
 
 function seedInventoryFromTasks(){
   return [
     ...defaultIntervalTasks.map(t => normalizeInventoryItem({ id:`inv_${t.id}`, name:t.name, qtyNew:0, qtyOld:0, unit:"pcs", note:"", pn:t.pn||"", link:t.storeLink||"", price:t.price!=null?Number(t.price):null })),
     ...defaultAsReqTasks.map(t => normalizeInventoryItem({ id:`inv_${t.id}`, name:t.name, qtyNew:0, qtyOld:0, unit:"pcs", note:"", pn:t.pn||"", link:t.storeLink||"", price:t.price!=null?Number(t.price):null })),
   ].filter(Boolean);
 }
 
 function buildOrderRequestCode(dateISO){
   const base = parseDateLocal(dateISO) || new Date();
   const y = base.getFullYear();
   const m = String(base.getMonth()+1).padStart(2, "0");
   const d = String(base.getDate()).padStart(2, "0");
   const hh = String(base.getHours()).padStart(2, "0");
   const mm = String(base.getMinutes()).padStart(2, "0");
   return `ORD-${y}${m}${d}-${hh}${mm}`;
 }
 
 function normalizeOrderItem(raw){
   if (!raw) return null;
   const qtyNum = Number(raw.qty);
   const qty = Number.isFinite(qtyNum) && qtyNum > 0 ? qtyNum : 1;
@@ -1755,84 +1966,86 @@ function createOrderRequest(items){
     note: "",
     items: []
   };
   if (Array.isArray(items) && items.length){
     template.items = items.map(cloneOrderRequestItem).filter(Boolean);
   }
   return template;
 }
 
 function buildCleanState(){
 const pumpDefaults = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] };
   return {
     schema: APP_SCHEMA,
     totalHistory: [],
     tasksInterval: defaultIntervalTasks.slice(),
     tasksAsReq: defaultAsReqTasks.slice(),
     inventory: seedInventoryFromTasks(),
     cuttingJobs: [],
     completedCuttingJobs: [],
     orderRequests: [createOrderRequest()],
     orderRequestTab: "active",
     dailyCutHours: [],
     garnetCleanings: [],
     pumpEff: { ...pumpDefaults },
     deletedItems: [],
+    jobFolders: defaultJobFolders(),
     dashboardLayout: {},
     costLayout: {}
   };
 }
 
 async function clearAllAppData(){
   try {
     const label = (()=>{
       try {
         return `Workspace snapshot (${new Date().toLocaleString()})`;
       } catch (_){
         return "Workspace snapshot";
       }
     })();
     recordDeletedItem("workspace", snapshotWorkspaceForTrash(), { reason: "clear-all", label });
   } catch (err) {
     console.warn("Failed to snapshot workspace before clearing", err);
   }
   const defaults = buildCleanState();
   defaults.deletedItems = deletedItems.map(entry => ({
     id: entry.id,
     type: entry.type,
     payload: cloneStructured(entry.payload),
     meta: entry.meta && typeof entry.meta === "object" ? { ...entry.meta } : {},
     label: entry.label,
     deletedAt: entry.deletedAt
   }));
 
   if (Array.isArray(window.settingsFolders)) window.settingsFolders.length = 0;
   else window.settingsFolders = [];
   if (window.settingsOpenFolders instanceof Set) window.settingsOpenFolders.clear();
   else window.settingsOpenFolders = new Set();
   window.maintenanceSearchTerm = "";
   window.pendingMaintenanceAddFromInventory = null;
+  window.jobFolders = defaultJobFolders();
 
   adoptState(defaults);
   resetHistoryToCurrent();
 
   try {
     if (typeof window.localStorage !== "undefined" && window.localStorage){
       const storage = window.localStorage;
       [
         "dashboard_layout_windows_v1",
         "cost_layout_windows_v1",
         "omax_tasks_interval_v6",
         "omax_tasks_asreq_v6"
       ].forEach(key => {
         try { storage.removeItem(key); } catch(_){ }
       });
     }
   } catch (err) {
     console.warn("Unable to clear layout storage", err);
   }
 
   try { if (window.dashboardLayoutState) delete window.dashboardLayoutState; } catch(_){ }
   try { if (window.costLayoutState) delete window.costLayoutState; } catch(_){ }
   try {
     window.cloudDashboardLayout = {};
     window.cloudDashboardLayoutLoaded = true;
 
EOF
)v 