 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/js/calendar.js b/js/calendar.js
index cb06b004b79d1f0b53223d4eb9397178b27a5d21..4af0e66e761ca6dbddceeaac275a25ff34831c9a 100644
--- a/js/calendar.js
+++ b/js/calendar.js
@@ -428,50 +428,72 @@ function removeCalendarTaskFamily(meta){
     window.tasksInterval = list;
   }
   return true;
 }
 
 function getGarnetEntries(){
   if (!Array.isArray(window.garnetCleanings)) window.garnetCleanings = [];
   return window.garnetCleanings;
 }
 
 function formatGarnetTime(value){
   const normalized = normalizeTimeString(value);
   if (!normalized) return "—";
   const [hhStr, mmStr] = normalized.split(":");
   const hh = Number(hhStr);
   const suffix = hh >= 12 ? "PM" : "AM";
   const hour12 = ((hh + 11) % 12) + 1;
   return `${hour12}:${mmStr} ${suffix}`;
 }
 
 function formatGarnetRange(start, end){
   const startTxt = formatGarnetTime(start);
   const endTxt = formatGarnetTime(end);
   return `${startTxt} – ${endTxt}`;
 }
+
+function formatDowntimeSummary(hours){
+  const value = Number(hours);
+  if (!Number.isFinite(value) || value <= 0) return "";
+  let decimals = 0;
+  if (!Number.isInteger(value)){
+    decimals = value < 1 ? 2 : 1;
+  }
+  return `${value.toFixed(decimals)} hr down`;
+}
+
+function formatMaintenanceCost(cost){
+  const value = Number(cost);
+  if (!Number.isFinite(value) || value <= 0) return "";
+  const decimals = value < 1000 ? 2 : 0;
+  return new Intl.NumberFormat(undefined, {
+    style: "currency",
+    currency: "USD",
+    minimumFractionDigits: decimals,
+    maximumFractionDigits: decimals
+  }).format(value);
+}
 function makeBubble(anchor){
   clearTimeout(bubbleTimer);
   bubbleTimer = null;
   hideBubble();
   const b = document.createElement("div"); b.id = "bubble"; b.className = "bubble"; document.body.appendChild(b);
   const rect = anchor.getBoundingClientRect();
   b.style.left = `${rect.left + window.scrollX}px`;
   b.style.top  = `${rect.bottom + window.scrollY}px`;
   b.addEventListener("mouseenter", ()=>clearTimeout(bubbleTimer));
   b.addEventListener("mouseleave", hideBubbleSoon);
   return b;
 }
 
 function completeTask(taskId){
   let meta = findCalendarTaskMeta(taskId);
   if (!meta) return;
   if (isTemplateTask(meta.task) && meta.task.mode === "interval"){
     const instance = scheduleExistingIntervalTask(meta.task, { dateISO: ymd(new Date()) });
     if (instance){
       const nextMeta = findCalendarTaskMeta(instance.id);
       if (nextMeta) meta = nextMeta;
       else meta = { task: instance, mode: "interval", list: window.tasksInterval, index: window.tasksInterval.indexOf(instance) };
     }
   }
   const todayKey = normalizeDateKey(new Date());
@@ -1127,64 +1149,74 @@ function projectIntervalDueDates(task, options = {}){
   events.sort((a,b)=> a.dateISO.localeCompare(b.dateISO));
   return events;
 }
 
 function renderCalendar(){
   const container = $("#months");
   if (!container) return;
   let showAll = Boolean(window.__calendarShowAllMonths);
   const editingHours = isCalendarHoursEditing();
   const hoursMap = typeof getDailyCutHoursMap === "function" ? getDailyCutHoursMap() : new Map();
   container.innerHTML = "";
   const block = container.closest(".calendar-block");
   if (block){
     block.classList.toggle("calendar-block--hours-editing", editingHours);
   }
 
   const dueMap = {};
   function pushTaskEvent(task, iso, status){
     if (!task || !iso) return;
     const key = normalizeDateKey(iso);
     if (!key) return;
     const events = dueMap[key] ||= [];
     const id = String(task.id);
     const statusKey = status || "due";
     const statusPriority = { completed: 3, manual: 2, due: 1 };
+    const downtimeRaw = typeof readTaskDowntimeHours === "function"
+      ? (readTaskDowntimeHours(task) ?? 0)
+      : (Number.isFinite(Number(task?.downtimeHours)) ? Number(task.downtimeHours) : 0);
+    const downtimeHours = Number.isFinite(downtimeRaw) && downtimeRaw > 0 ? downtimeRaw : 0;
+    const priceRaw = typeof readTaskMaintenanceCost === "function"
+      ? readTaskMaintenanceCost(task)
+      : Number(task?.price);
+    const price = Number.isFinite(priceRaw) && priceRaw > 0 ? priceRaw : 0;
     const existing = events.find(ev => ev.type === "task" && ev.id === id);
     if (existing){
       existing.name = task.name;
       const existingStatus = existing.status || "due";
       const existingPriority = statusPriority[existingStatus] || 1;
       const nextPriority = statusPriority[statusKey] || 1;
       if (nextPriority >= existingPriority){
         existing.status = statusKey;
       }
       existing.mode = task && task.mode === "asreq" ? "asreq" : "interval";
       existing.dateISO = key;
+      existing.downtimeHours = downtimeHours;
+      existing.price = price;
       return;
     }
-    events.push({ type:"task", id, name:task.name, status: statusKey, mode: task && task.mode === "asreq" ? "asreq" : "interval", dateISO: key });
+    events.push({ type:"task", id, name:task.name, status: statusKey, mode: task && task.mode === "asreq" ? "asreq" : "interval", dateISO: key, downtimeHours, price });
   }
 
   const intervalTasks = Array.isArray(window.tasksInterval)
     ? window.tasksInterval.filter(t => t && t.mode === "interval" && isInstanceTask(t))
     : [];
   const completedByTask = new Map();
   intervalTasks.forEach(t => {
     if (!t) return;
     const rawDates = Array.isArray(t.completedDates) ? t.completedDates : [];
     const set = new Set();
     rawDates.map(normalizeDateKey).filter(Boolean).forEach(key => set.add(key));
     completedByTask.set(String(t.id), set);
   });
   intervalTasks.forEach(t => {
     if (!t) return;
     const taskKey = String(t.id);
     let completedKeys = completedByTask.get(taskKey);
     if (!(completedKeys instanceof Set)){
       completedKeys = new Set();
       completedByTask.set(taskKey, completedKeys);
     }
     completedKeys.forEach(dateKey => {
       if (!dateKey) return;
       pushTaskEvent(t, dateKey, "completed");
     });
@@ -1445,50 +1477,54 @@ function renderCalendar(){
           if (!removeFn) return;
           const parsed = new Date(`${iso}T00:00:00`);
           const label = isNaN(parsed.getTime())
             ? iso
             : parsed.toLocaleDateString();
           const shouldRemove = window.confirm
             ? window.confirm(`Remove down time scheduled for ${label}?`)
             : true;
           if (!shouldRemove) return;
           removeFn(iso);
         });
       }
       (dueMap[key]||[]).forEach(ev=>{
         const chip = document.createElement("div");
         let cls = "event generic cal-task";
         if (ev.status === "completed") cls += " is-complete";
         chip.className = cls;
         chip.dataset.calTask = ev.id;
         chip.dataset.calStatus = ev.status || "due";
         if (ev.mode) chip.dataset.calMode = ev.mode;
         chip.dataset.calDate = ev.dateISO || key;
         let label = ev.name;
         if (ev.status === "completed") label += " (completed)";
         else if (ev.status === "manual") label += " (scheduled)";
         else label += " (due)";
+        const costText = formatMaintenanceCost(ev.price);
+        const downtimeText = formatDowntimeSummary(ev.downtimeHours);
+        if (costText) label += ` • ${costText}`;
+        if (downtimeText) label += ` • ${downtimeText}`;
         chip.textContent = label;
         cell.appendChild(chip);
       });
       (garnetMap[key]||[]).forEach(ev=>{
         const chip = document.createElement("div");
         let cls = "event garnet cal-garnet";
         if (ev.completed) cls += " is-complete";
         chip.className = cls;
         chip.dataset.calGarnet = ev.id;
         chip.textContent = `Garnet Cleaning (${formatGarnetRange(ev.startTime, ev.endTime)})`;
         cell.appendChild(chip);
       });
       (jobsMap[key]||[]).forEach(ev=>{
         const bar = document.createElement("div");
         let cls = "job-bar cal-job";
         if (ev.status === "completed") cls += " is-complete";
         bar.className = cls;
         bar.dataset.calJob = ev.id;
         bar.textContent = ev.status === "completed" ? `${ev.name} (completed)` : ev.name;
         cell.appendChild(bar);
       });
       const addBtn = document.createElement("button");
       addBtn.type = "button";
       addBtn.className = "day-add-bubble";
       addBtn.textContent = "+";
diff --git a/js/core.js b/js/core.js
index 748932c2dad91b4f21fcca92833c75bf826bf32d..1dfd3af4eed747e9113f4697a943c11073397409 100644
--- a/js/core.js
+++ b/js/core.js
@@ -353,50 +353,132 @@ const defaultIntervalTasks = [
   { id:"ro_softener_daily_chk", name:"RO / Softener feed pressure & water quality — daily", interval:8, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"mixing_tube_rotation",  name:"Mixing tube rotation", interval:8, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"jewel_nozzle_clean",    name:"Jewell orifice & nozzle body cleaning (weekly)", interval:56, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"check_bonding_strap",   name:"Check hopper bonding strap (annually)", interval:2920, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"lube_z_axis",           name:"Lubricate Z-axis rail shafts & lead screw (annually)", interval:2920, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", completedDates: [] },
   { id:"filter_housing_or_2y",  name:"Filter housing O-ring (2 years / if leaking)", interval:5840, sinceBase:null, anchorTotal:null, manualLink:"", storeLink:"", pn:"208665", price:4.85, completedDates: [] }
 ];
 const defaultAsReqTasks = [
   { id:"purge_hopper_pressure_pot", name:"Purge hopper pressure pot", condition:"As required", manualLink:"", storeLink:"" },
   { id:"replace_pot_sensors",       name:"Replace pressure pot sensors", condition:"When failed", manualLink:"", storeLink:"" },
   { id:"empty_hopper_abrasive",     name:"Empty hopper abrasive material", condition:"If debris/contamination", manualLink:"", storeLink:"" },
 
   { id:"replace_pinch_valve", name:"Replace hopper pinch valve", condition:"When damaged", manualLink:"", storeLink:"", pn:"204160", price:292 },
   { id:"replace_feed_hose",   name:"Replace abrasive feed hose", condition:"When damaged", manualLink:"", storeLink:"", pn:"302240", price:121 },
   { id:"ro_filter_housing",   name:"RO Filter Housing",          condition:"As needed",   manualLink:"", storeLink:"", pn:"208663", price:137 },
   { id:"ro_micron_filter",    name:"RO Micron filter",           condition:"Per water quality/pressure", manualLink:"", storeLink:"", pn:"209260-01", price:35.5 },
   { id:"ro_carbon_filter",    name:"RO Carbon filter",           condition:"Per chlorine breakthrough",  manualLink:"", storeLink:"", pn:"204365", price:25 },
   { id:"ro_calcite_filter",   name:"RO Calcite filter",          condition:"Per water quality / pH",     manualLink:"", storeLink:"", pn:"204876", price:72 },
 
   { id:"inspect_abrasive_tube", name:"Abrasive tubing inspection", condition:"Before each use", manualLink:"", storeLink:"" },
   { id:"clean_xy_strips",       name:"Clean X– & Y–axis magnetic encoder strips", condition:"If errors occur", manualLink:"", storeLink:"" },
   { id:"clean_lube_ballscrews", name:"Clean & lubricate ball screws", condition:"If debris occurs", manualLink:"", storeLink:"" },
   { id:"clean_rails",           name:"Clean X-rails & Y-bridge rails", condition:"If debris occurs", manualLink:"", storeLink:"" }
 ];
 
+function readTaskDowntimeHours(task){
+  if (!task || typeof task !== "object") return null;
+  const raw = task.downtimeHours ?? task.downTime ?? task.downtime;
+  const num = Number(raw);
+  if (!Number.isFinite(num) || num < 0) return null;
+  return num;
+}
+
+function readTaskMaintenanceCost(task){
+  if (!task || typeof task !== "object") return 0;
+  let total = 0;
+  const direct = Number(task.price);
+  if (Number.isFinite(direct) && direct > 0){
+    total += direct;
+  }
+  if (Array.isArray(task.parts)){
+    for (const part of task.parts){
+      const partPrice = Number(part?.price);
+      if (Number.isFinite(partPrice) && partPrice > 0){
+        total += partPrice;
+      }
+    }
+  }
+  return total;
+}
+
+if (typeof window !== "undefined"){
+  window.readTaskDowntimeHours = readTaskDowntimeHours;
+  window.readTaskMaintenanceCost = readTaskMaintenanceCost;
+}
+
+let maintenanceTasksVersion = typeof window !== "undefined" && Number.isFinite(Number(window.__maintenanceTasksVersion))
+  ? Number(window.__maintenanceTasksVersion)
+  : 0;
+
+function broadcastMaintenanceTasksUpdated(options = {}){
+  maintenanceTasksVersion += 1;
+  if (typeof window !== "undefined"){
+    window.__maintenanceTasksVersion = maintenanceTasksVersion;
+  }
+
+  const detail = { version: maintenanceTasksVersion, options: { ...options } };
+  if (typeof document !== "undefined" && typeof document.dispatchEvent === "function"){
+    try {
+      document.dispatchEvent(new CustomEvent("maintenanceTasksUpdated", { detail }));
+    } catch (err) {
+      console.warn("Failed to dispatch maintenanceTasksUpdated", err);
+    }
+  }
+
+  const refreshCalendar = options && options.refreshCalendar !== false;
+  const refreshDashboard = options && options.refreshDashboard !== false;
+  const refreshCosts = options && options.refreshCosts !== false;
+
+  if (refreshCalendar && typeof renderCalendar === "function"){
+    try { renderCalendar(); }
+    catch (err) { console.warn("Failed to refresh calendar after maintenance save", err); }
+  }
+
+  if (refreshDashboard && typeof renderDashboard === "function"){
+    try { renderDashboard(); }
+    catch (err) { console.warn("Failed to refresh dashboard after maintenance save", err); }
+  }
+
+  if (refreshCosts && typeof renderCosts === "function"){
+    try {
+      const hash = (typeof location !== "undefined" && typeof location.hash === "string")
+        ? location.hash.toLowerCase()
+        : "";
+      if (refreshCosts === true || hash === "#/costs" || hash === "#costs"){
+        renderCosts();
+      }
+    } catch (err) {
+      console.warn("Failed to refresh cost analysis after maintenance save", err);
+    }
+  }
+}
+
+if (typeof window !== "undefined"){
+  window.broadcastMaintenanceTasksUpdated = broadcastMaintenanceTasksUpdated;
+}
+
 function resolveTaskVariant(task){
   if (!task || typeof task !== "object") return null;
   const raw = typeof task.variant === "string" ? task.variant.toLowerCase() : "";
   if (raw === "template" || raw === "instance") return raw;
   if (task.templateId != null && String(task.templateId) !== String(task.id)) return "instance";
   return null;
 }
 
 function isTemplateTask(task){
   const variant = resolveTaskVariant(task);
   if (variant) return variant === "template";
   return !!(task && (task.mode === "interval" || task.mode === "asreq"));
 }
 
 function isInstanceTask(task){
   return resolveTaskVariant(task) === "instance";
 }
 
 function ensureTaskVariant(task, type){
   if (!task || typeof task !== "object") return;
   const variant = resolveTaskVariant(task);
   if (variant === "template" || variant === "instance") return;
   if (type === "interval" || type === "asreq"){
     task.variant = "template";
   }
@@ -1074,50 +1156,53 @@ function setJobFolders(raw){
     }
   }
   return window.jobFolders;
 }
 
 function snapshotJobFolders(){
   const source = Array.isArray(window.jobFolders) ? window.jobFolders : defaultJobFolders();
   const normalized = normalizeJobFolders(source);
   window.jobFolders = normalized;
   return cloneJobFolders(normalized);
 }
 
 /* ===================== Persisted state ===================== */
 if (!Array.isArray(window.totalHistory)) window.totalHistory = [];   // [{dateISO, hours}]
 if (!Array.isArray(window.tasksInterval)) window.tasksInterval = [];
 if (!Array.isArray(window.tasksAsReq))   window.tasksAsReq   = [];
 if (!Array.isArray(window.inventory))    window.inventory    = [];
 if (!Array.isArray(window.cuttingJobs))  window.cuttingJobs  = [];   // [{id,name,estimateHours,material,materialCost,materialQty,chargeRate,notes,startISO,dueISO,manualLogs:[{dateISO,completedHours}],files:[{name,dataUrl,type,size,addedAt}]}]
 if (!Array.isArray(window.completedCuttingJobs)) window.completedCuttingJobs = [];
 if (!Array.isArray(window.pendingNewJobFiles)) window.pendingNewJobFiles = [];
 if (!Array.isArray(window.orderRequests)) window.orderRequests = [];
 if (!Array.isArray(window.garnetCleanings)) window.garnetCleanings = [];
 if (!Array.isArray(window.dailyCutHours)) window.dailyCutHours = [];
 if (!Array.isArray(window.jobFolders)) window.jobFolders = defaultJobFolders();
 if (typeof window.orderRequestTab !== "string") window.orderRequestTab = "active";
+if (typeof window.downtimeBaseLossRate !== "number" || !Number.isFinite(window.downtimeBaseLossRate) || window.downtimeBaseLossRate < 0){
+  window.downtimeBaseLossRate = 150;
+}
 
 if (typeof window.pumpEff !== "object" || !window.pumpEff){
   window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] };
 }
 if (!Array.isArray(window.pumpEff.entries)) window.pumpEff.entries = [];
 if (!Array.isArray(window.pumpEff.notes)) window.pumpEff.notes = [];
 
 let totalHistory = window.totalHistory;
 let tasksInterval = window.tasksInterval;
 let tasksAsReq    = window.tasksAsReq;
 let inventory     = window.inventory;
 let cuttingJobs   = window.cuttingJobs;
 let completedCuttingJobs = window.completedCuttingJobs;
 let orderRequests = window.orderRequests;
 let orderRequestTab = window.orderRequestTab;
 let garnetCleanings = window.garnetCleanings;
 let dailyCutHours = window.dailyCutHours;
 let jobFolders = window.jobFolders;
 
 function refreshGlobalCollections(){
   if (typeof window === "undefined") return;
 
   if (!Array.isArray(window.totalHistory)) window.totalHistory = [];
   totalHistory = window.totalHistory;
 
@@ -1125,50 +1210,54 @@ function refreshGlobalCollections(){
   tasksInterval = window.tasksInterval;
 
   if (!Array.isArray(window.tasksAsReq)) window.tasksAsReq = [];
   tasksAsReq = window.tasksAsReq;
 
   if (!Array.isArray(window.inventory)) window.inventory = [];
   inventory = window.inventory;
 
   if (!Array.isArray(window.cuttingJobs)) window.cuttingJobs = [];
   cuttingJobs = window.cuttingJobs;
 
   if (!Array.isArray(window.completedCuttingJobs)) window.completedCuttingJobs = [];
   completedCuttingJobs = window.completedCuttingJobs;
 
   if (!Array.isArray(window.orderRequests)) window.orderRequests = [];
   orderRequests = window.orderRequests;
 
   if (!Array.isArray(window.garnetCleanings)) window.garnetCleanings = [];
   garnetCleanings = window.garnetCleanings;
 
   if (!Array.isArray(window.dailyCutHours)) window.dailyCutHours = [];
   dailyCutHours = window.dailyCutHours;
 
   if (!Array.isArray(window.jobFolders)) window.jobFolders = defaultJobFolders();
   jobFolders = window.jobFolders;
+
+  if (typeof window.downtimeBaseLossRate !== "number" || !Number.isFinite(window.downtimeBaseLossRate) || window.downtimeBaseLossRate < 0){
+    window.downtimeBaseLossRate = 150;
+  }
 }
 
 /* ================ Jobs editing & render flags ================ */
 if (!(window.editingJobs instanceof Set)) window.editingJobs = new Set();
 if (!(window.editingCompletedJobs instanceof Set)) window.editingCompletedJobs = new Set();
 if (typeof window.RENDER_TOTAL !== "number") window.RENDER_TOTAL = null;
 if (typeof window.RENDER_DELTA !== "number") window.RENDER_DELTA = 0;
 
 const editingJobs  = window.editingJobs;
 let   RENDER_TOTAL = window.RENDER_TOTAL;
 let   RENDER_DELTA = window.RENDER_DELTA;
 
 function getEditingCompletedJobsSet(){
   if (!(window.editingCompletedJobs instanceof Set)){
     window.editingCompletedJobs = new Set();
   }
   return window.editingCompletedJobs;
 }
 
 window.getEditingCompletedJobsSet = getEditingCompletedJobsSet;
 
 function cloneFolders(list){
   if (!Array.isArray(list)) return [];
   return list.map(folder => ({ ...folder }));
 }
@@ -1236,50 +1325,53 @@ function snapshotState(){
     ? window.cloudDashboardLayout
     : (window.dashboardLayoutState && window.dashboardLayoutState.layoutById);
   const costLayoutSource = window.cloudCostLayoutLoaded
     ? window.cloudCostLayout
     : (window.costLayoutState && window.costLayoutState.layoutById);
   return {
     schema: window.APP_SCHEMA || APP_SCHEMA,
     totalHistory,
     tasksInterval,
     tasksAsReq,
     inventory,
     cuttingJobs,
     completedCuttingJobs,
     orderRequests,
     orderRequestTab,
     garnetCleanings,
     dailyCutHours: Array.isArray(dailyCutHours)
       ? dailyCutHours.map(entry => ({ ...entry }))
       : [],
     pumpEff: safePumpEff,
     deletedItems: trashSnapshot,
     settingsFolders: foldersSnapshot,
     folders: cloneFolders(window.settingsFolders),
     jobFolders: snapshotJobFolders(),
     dashboardLayout: cloneStructured(dashLayoutSource) || {},
+    downtimeBaseLossRate: (typeof window.downtimeBaseLossRate === "number" && Number.isFinite(window.downtimeBaseLossRate) && window.downtimeBaseLossRate >= 0)
+      ? Number(window.downtimeBaseLossRate)
+      : 150,
     costLayout: cloneStructured(costLayoutSource) || {}
   };
 }
 
 /* ======================== HISTORY ========================= */
 const HISTORY_LIMIT = 50;
 const undoStack = [];
 const redoStack = [];
 let currentSnapshotJSON = null;
 let suppressHistory = false;
 let skipNextHistoryCapture = false;
 
 function syncRenderTotalsFromHistory(){
   const len = Array.isArray(totalHistory) ? totalHistory.length : 0;
   const last = len ? totalHistory[len - 1] : null;
   const prev = len > 1 ? totalHistory[len - 2] : null;
 
   const curHours = last != null ? Number(last.hours) : NaN;
   const prevHours = prev != null ? Number(prev.hours) : NaN;
 
   const cur = Number.isFinite(curHours) ? curHours : null;
   const prevVal = Number.isFinite(prevHours) ? prevHours : null;
   const delta = (cur != null && prevVal != null) ? Math.max(0, cur - prevVal) : null;
 
   RENDER_TOTAL = cur;
@@ -1775,50 +1867,56 @@ function adoptState(doc){
       ensureTaskVariant(task, task && task.mode);
       const val = Number(task && task.order);
       if (Number.isFinite(val) && val > maxOrder) maxOrder = val;
     }
   }
   for (const folder of window.settingsFolders){
     const val = Number(folder && folder.order);
     if (Number.isFinite(val) && val > maxOrder) maxOrder = val;
   }
   window._maintOrderCounter = maxOrder;
 
   // Pump efficiency (guard against reading an undefined identifier)
   const pe = (typeof window.pumpEff === "object" && window.pumpEff)
     ? window.pumpEff
     : (window.pumpEff = { baselineRPM:null, baselineDateISO:null, entries:[], notes:[] });
   if (!Array.isArray(pe.entries)) pe.entries = [];
   if (!Array.isArray(pe.notes)) pe.notes = [];
 
   if (data.pumpEff && typeof data.pumpEff === "object"){
     pe.baselineRPM     = (data.pumpEff.baselineRPM ?? pe.baselineRPM);
     pe.baselineDateISO = (data.pumpEff.baselineDateISO ?? pe.baselineDateISO);
     pe.entries         = Array.isArray(data.pumpEff.entries) ? data.pumpEff.entries.slice() : pe.entries;
     pe.notes           = Array.isArray(data.pumpEff.notes) ? data.pumpEff.notes.slice() : pe.notes;
   }
 
+  if (Number.isFinite(Number(data.downtimeBaseLossRate)) && Number(data.downtimeBaseLossRate) >= 0){
+    window.downtimeBaseLossRate = Number(data.downtimeBaseLossRate);
+  }else if (typeof window.downtimeBaseLossRate !== "number" || !Number.isFinite(window.downtimeBaseLossRate) || window.downtimeBaseLossRate < 0){
+    window.downtimeBaseLossRate = 150;
+  }
+
   ensureTaskCategories();
   ensureJobCategories();
   syncRenderTotalsFromHistory();
 }
 
 
 const saveCloudInternal = debounce(async ()=>{
   if (!FB.ready || !FB.docRef) return;
   try{ await FB.docRef.set(snapshotState(), { merge:true }); }catch(e){ console.error("Cloud save failed:", e); }
 }, 300);
 function saveCloudDebounced(){
   try {
     setSettingsFolders(window.settingsFolders);
   } catch (err) {
     console.warn("Failed to normalize folders before save:", err);
   }
   captureHistorySnapshot();
   saveCloudInternal();
 }
 async function loadFromCloud(){
   if (!FB.ready || !FB.docRef) return;
   try{
     const snap = await FB.docRef.get();
     if (snap.exists){
       const data = snap.data() || {};
diff --git a/js/renderers.js b/js/renderers.js
index f34f72648c86af57e65904f71cb8179dd251063e..9bc1d67b5c317542f55c14f5b871086ec3fb246a 100644
--- a/js/renderers.js
+++ b/js/renderers.js
@@ -117,67 +117,131 @@ function ensureTaskManualHistory(task){
       clone.estimatedDailyHours = Number.isFinite(est) && est > 0 ? est : null;
     } else {
       clone.estimatedDailyHours = null;
     }
     normalized.push(clone);
   });
   normalized.sort((a,b)=> String(a.dateISO).localeCompare(String(b.dateISO)));
   task.manualHistory = normalized;
   return task.manualHistory;
 }
 
 function createIntervalTaskInstance(template){
   if (!template || template.mode !== "interval") return null;
   const templateId = template.templateId != null ? template.templateId : template.id;
   const intervalVal = Number(template.interval);
   const copy = {
     id: genId(template.name || "task"),
     variant: "instance",
     templateId: templateId != null ? templateId : null,
     mode: "interval",
     name: template.name || "",
     manualLink: template.manualLink || "",
     storeLink: template.storeLink || "",
     pn: template.pn || "",
     price: template.price != null && Number.isFinite(Number(template.price)) ? Number(template.price) : null,
+    downtimeHours: typeof readTaskDowntimeHours === "function"
+      ? (readTaskDowntimeHours(template) ?? null)
+      : (Number.isFinite(Number(template?.downtimeHours)) && Number(template.downtimeHours) >= 0 ? Number(template.downtimeHours) : null),
     cat: template.cat ?? null,
     parentTask: template.parentTask ?? null,
     order: ++window._maintOrderCounter,
     interval: Number.isFinite(intervalVal) && intervalVal > 0 ? intervalVal : 8,
     calendarDateISO: null,
     sinceBase: 0,
     anchorTotal: null,
     completedDates: [],
     manualHistory: [],
     note: template.note || ""
   };
   if (Array.isArray(template.parts)){
     copy.parts = template.parts.map(part => part ? { ...part } : part).filter(Boolean);
   }
   return copy;
 }
 
+async function ensureMaintenanceTaskReadyForCalendar(task){
+  const outcome = { proceed: true, missingCost: false, missingDowntime: false };
+  if (!task || typeof task !== "object") return outcome;
+
+  const totalCost = typeof readTaskMaintenanceCost === "function"
+    ? readTaskMaintenanceCost(task)
+    : Number(task?.price);
+  const downtimeVal = typeof readTaskDowntimeHours === "function"
+    ? readTaskDowntimeHours(task)
+    : Number(task?.downtimeHours);
+
+  const hasCost = Number.isFinite(totalCost) && totalCost > 0;
+  const hasDowntime = Number.isFinite(downtimeVal) && downtimeVal > 0;
+  outcome.missingCost = !hasCost;
+  outcome.missingDowntime = !hasDowntime;
+  if (hasCost && hasDowntime) return outcome;
+
+  const name = task && task.name ? `"${task.name}"` : "this maintenance task";
+  const summary = (!hasCost && !hasDowntime)
+    ? "a cost and downtime hours"
+    : (!hasCost ? "a cost" : "downtime hours");
+  const items = [];
+  if (!hasCost) items.push("Add a parts or labor cost greater than $0.");
+  if (!hasDowntime) items.push("Set downtime hours greater than 0.");
+
+  if (typeof showConfirmChoices === "function"){
+    const choice = await showConfirmChoices({
+      title: "Update maintenance task details",
+      message: `${name} is missing ${summary}. Update it before scheduling?`,
+      items,
+      cancelText: "Cancel",
+      confirmText: "Edit in settings",
+      confirmVariant: "primary",
+      secondaryText: "Schedule anyway",
+      secondaryVariant: "secondary"
+    });
+    if (choice === "cancel"){
+      return { ...outcome, proceed: false, cancelled: true };
+    }
+    if (choice === "confirm"){
+      const targetId = isTemplateTask(task)
+        ? (task.id != null ? task.id : task.templateId)
+        : (task.templateId != null ? task.templateId : task.id);
+      if (targetId != null && typeof openSettingsAndReveal === "function"){
+        try { openSettingsAndReveal(targetId); }
+        catch (err) { console.warn("Failed to open Maintenance Settings for task", err); }
+      }
+      return { ...outcome, proceed: false, redirected: true };
+    }
+    return outcome;
+  }
+
+  const fallback = window.confirm
+    ? window.confirm(`${name} is missing ${summary}. Continue scheduling without updating?`)
+    : true;
+  if (!fallback){
+    return { ...outcome, proceed: false, cancelled: true };
+  }
+  return outcome;
+}
+
 function scheduleExistingIntervalTask(task, { dateISO = null } = {}){
   if (!task || task.mode !== "interval") return null;
   if (!Array.isArray(tasksInterval)){
     if (Array.isArray(window.tasksInterval)){
       tasksInterval = window.tasksInterval;
     }else{
       tasksInterval = [];
       window.tasksInterval = tasksInterval;
     }
   }
   let template = task;
   let instance = task;
   if (!isInstanceTask(task)){
     template = task;
     ensureTaskVariant(template, "interval");
     template.templateId = template.templateId != null ? template.templateId : template.id;
     instance = createIntervalTaskInstance(template);
     if (!instance) return null;
     tasksInterval.unshift(instance);
     window.tasksInterval = tasksInterval;
   }else{
     const templateId = task.templateId != null ? String(task.templateId) : null;
     if (templateId){
       template = tasksInterval.find(item => item && String(item.id) === templateId) || template;
     }
@@ -2543,50 +2607,51 @@ function renderDashboard(){
       const from = findTaskButton(e.target);
       const to = findTaskButton(e.relatedTarget);
       maybeHideBubble(from, to);
     });
   }
 
   if (typeof window._maintOrderCounter === "undefined") window._maintOrderCounter = 0;
 
   const modal            = document.getElementById("dashboardAddModal");
   const closeBtn         = document.getElementById("dashboardModalClose");
   const taskForm         = document.getElementById("dashTaskForm");
   const taskExistingForm = document.getElementById("dashTaskExistingForm");
   const downForm         = document.getElementById("dashDownForm");
   const jobForm          = document.getElementById("dashJobForm");
   const downList         = document.getElementById("dashDownList");
   const downDateInput    = document.getElementById("dashDownDate");
   const taskTypeSelect   = document.getElementById("dashTaskType");
   const taskNameInput    = document.getElementById("dashTaskName");
   const taskIntervalInput= document.getElementById("dashTaskInterval");
   const taskLastInput    = document.getElementById("dashTaskLast");
   const taskConditionInput = document.getElementById("dashTaskCondition");
   const taskManualInput  = document.getElementById("dashTaskManual");
   const taskStoreInput   = document.getElementById("dashTaskStore");
   const taskPNInput      = document.getElementById("dashTaskPN");
   const taskPriceInput   = document.getElementById("dashTaskPrice");
+  const taskDowntimeInput= document.getElementById("dashTaskDowntime");
   const categorySelect   = document.getElementById("dashTaskCategory");
   const taskDateInput    = document.getElementById("dashTaskDate");
   const subtaskList      = document.getElementById("dashSubtaskList");
   const addSubtaskBtn    = document.getElementById("dashAddSubtask");
   const taskOptionStage  = modal?.querySelector('[data-task-option-stage]');
   const taskOptionButtons= Array.from(modal?.querySelectorAll('[data-task-option]') || []);
   const taskExistingSearchInput = document.getElementById("dashTaskExistingSearch");
   const taskExistingSearchWrapper = taskExistingForm?.querySelector(".task-existing-search");
   const existingTaskSelect = document.getElementById("dashTaskExistingSelect");
   const existingTaskEmpty  = taskExistingForm?.querySelector('[data-task-existing-empty]');
   const existingTaskSearchEmpty = taskExistingForm?.querySelector('[data-task-existing-search-empty]');
   const jobNameInput     = document.getElementById("dashJobName");
   const jobEstimateInput = document.getElementById("dashJobEstimate");
   const jobChargeInput   = document.getElementById("dashJobCharge");
   const jobMaterialInput = document.getElementById("dashJobMaterial");
   const jobMaterialCostInput = document.getElementById("dashJobMaterialCost");
   const jobMaterialQtyInput = document.getElementById("dashJobMaterialQty");
   const jobStartInput    = document.getElementById("dashJobStart");
   const jobDueInput      = document.getElementById("dashJobDue");
   const jobCategoryInput = document.getElementById("dashJobCategory");
   const garnetForm       = document.getElementById("dashGarnetForm");
   const garnetDateInput  = document.getElementById("dashGarnetDate");
   const garnetStartInput = document.getElementById("dashGarnetStart");
   const garnetEndInput   = document.getElementById("dashGarnetEnd");
   const garnetNoteInput  = document.getElementById("dashGarnetNote");
@@ -3333,193 +3398,230 @@ function renderDashboard(){
   });
 
   taskOptionButtons.forEach(btn => {
     btn.addEventListener("click", ()=>{
       const variant = btn.getAttribute("data-task-option");
       activateTaskVariant(variant === "existing" ? "existing" : "new");
     });
   });
 
   taskExistingSearchInput?.addEventListener("input", ()=>{
     refreshExistingTaskOptions(taskExistingSearchInput.value);
   });
 
   taskTypeSelect?.addEventListener("change", ()=> syncTaskMode(taskTypeSelect.value));
   syncTaskMode(taskTypeSelect?.value || "interval");
   syncTaskDateInput();
   populateCategoryOptions();
   resetExistingTaskForm();
   showTaskOptionStage();
 
   addSubtaskBtn?.addEventListener("click", ()=>{
     const row = createSubtaskRow(taskTypeSelect?.value || "interval");
     if (row) subtaskList?.appendChild(row);
   });
 
-  taskForm?.addEventListener("submit", (e)=>{
+  taskForm?.addEventListener("submit", async (e)=>{
     e.preventDefault();
     if (!taskForm) return;
     const name = (taskNameInput?.value || "").trim();
     if (!name){ alert("Task name is required."); return; }
     const mode = (taskTypeSelect?.value === "asreq") ? "asreq" : "interval";
     const manual = (taskManualInput?.value || "").trim();
     const store  = (taskStoreInput?.value || "").trim();
     const pn     = (taskPNInput?.value || "").trim();
     const priceVal = taskPriceInput?.value;
     const price  = priceVal === "" ? null : Number(priceVal);
+    const downtimeRaw = taskDowntimeInput?.value ?? "";
+    let downtimeHours = null;
+    if (downtimeRaw !== ""){
+      const parsedDowntime = Number(downtimeRaw);
+      if (!Number.isFinite(parsedDowntime) || parsedDowntime < 0){ toast("Enter a valid down time value."); return; }
+      downtimeHours = parsedDowntime;
+    }
     const catId  = (categorySelect?.value || "").trim() || null;
     const id     = genId(name);
     const rawDate = (taskDateInput?.value || "").trim();
     const dateISO = rawDate ? ymd(rawDate) : "";
     const targetISO = dateISO || addContextDateISO || ymd(new Date());
     const calendarDateISO = targetISO || null;
     const base = {
       id,
       name,
       manualLink: manual,
       storeLink: store,
       pn,
       price: isFinite(price) ? price : null,
+      downtimeHours: downtimeHours,
       cat: catId,
       parentTask: null,
       order: ++window._maintOrderCounter,
       calendarDateISO: null
     };
     let message = "Task added";
+
+    const applySubtasks = ()=>{
+      const parentInterval = Number(taskIntervalInput?.value);
+      const subRows = subtaskList ? Array.from(subtaskList.querySelectorAll("[data-subtask-row]")) : [];
+      subRows.forEach(row => {
+        const subName = (row.querySelector("[data-subtask-name]")?.value || "").trim();
+        if (!subName) return;
+        const subTypeSel = row.querySelector("[data-subtask-type]");
+        const subMode = subTypeSel && subTypeSel.value === "asreq" ? "asreq" : "interval";
+        const subBase = {
+          id: genId(subName),
+          name: subName,
+          manualLink: "",
+          storeLink: "",
+          pn: "",
+          price: null,
+          cat: catId,
+          parentTask: id,
+          order: ++window._maintOrderCounter,
+          calendarDateISO: null
+        };
+        if (subMode === "interval"){
+          const intervalField = row.querySelector("[data-subtask-interval]");
+          let subInterval = Number(intervalField?.value);
+          if (!isFinite(subInterval) || subInterval <= 0){
+            subInterval = isFinite(parentInterval) && parentInterval > 0 ? parentInterval : 8;
+          }
+          const subTask = Object.assign({}, subBase, {
+            mode:"interval",
+            interval: subInterval,
+            sinceBase:0,
+            anchorTotal:null,
+            completedDates: [],
+            manualHistory: [],
+            variant: "template",
+            templateId: subBase.id
+          });
+          const curHours = getCurrentMachineHours();
+          const lastField = row.querySelector("[data-subtask-last]");
+          const baselineHours = parseBaselineHours(lastField?.value);
+          applyIntervalBaseline(subTask, { baselineHours, currentHours: curHours });
+          tasksInterval.unshift(subTask);
+        }else{
+          const condInput = row.querySelector("[data-subtask-condition-input]");
+          const subTask = Object.assign({}, subBase, {
+            mode:"asreq",
+            condition: (condInput?.value || "").trim() || "As required",
+            variant: "template",
+            templateId: subBase.id
+          });
+          tasksAsReq.unshift(subTask);
+        }
+      });
+    };
+
     if (mode === "interval"){
       let interval = Number(taskIntervalInput?.value);
       if (!isFinite(interval) || interval <= 0) interval = 8;
       const template = Object.assign({}, base, {
         mode:"interval",
         interval,
         sinceBase:0,
         anchorTotal:null,
         completedDates: [],
         manualHistory: [],
         variant: "template",
         templateId: id
       });
       const curHours = getCurrentMachineHours();
       const baselineHours = parseBaselineHours(taskLastInput?.value);
       applyIntervalBaseline(template, { baselineHours, currentHours: curHours });
+      const readiness = await ensureMaintenanceTaskReadyForCalendar(template);
+      if (!readiness.proceed){
+        if (readiness.redirected){
+          tasksInterval.unshift(template);
+          applySubtasks();
+          try { if (typeof saveTasks === "function") saveTasks(); } catch (_){}
+          try { saveCloudDebounced(); } catch (_){ }
+          if (typeof broadcastMaintenanceTasksUpdated === "function"){
+            try { broadcastMaintenanceTasksUpdated({ source: "calendar-add-blocked" }); }
+            catch (err) { console.warn("Failed to broadcast maintenance update", err); }
+          }
+          toast("Update maintenance cost and downtime before scheduling.");
+          closeModal();
+        }
+        return;
+      }
       tasksInterval.unshift(template);
+      applySubtasks();
       const instance = scheduleExistingIntervalTask(template, { dateISO: targetISO }) || template;
       const parsed = parseDateLocal(targetISO);
       const todayMidnight = new Date(); todayMidnight.setHours(0,0,0,0);
       let dateLabel = targetISO;
       let completed = false;
       if (parsed instanceof Date && !Number.isNaN(parsed.getTime())){
         const display = new Date(parsed.getTime());
         dateLabel = display.toLocaleDateString();
         const compare = new Date(parsed.getTime());
         compare.setHours(0,0,0,0);
         completed = compare.getTime() <= todayMidnight.getTime();
       }
       message = completed
         ? `Logged "${instance.name || "Task"}" as completed on ${dateLabel}`
         : `Scheduled "${instance.name || "Task"}" for ${dateLabel}`;
     }else{
       const condition = (taskConditionInput?.value || "").trim() || "As required";
       const task = Object.assign({}, base, { mode:"asreq", condition, variant: "template", templateId: id });
       tasksAsReq.unshift(task);
+      applySubtasks();
       message = "As-required task added to Maintenance Settings";
     }
 
-    const parentInterval = Number(taskIntervalInput?.value);
-    const subRows = subtaskList ? Array.from(subtaskList.querySelectorAll("[data-subtask-row]")) : [];
-    subRows.forEach(row => {
-      const subName = (row.querySelector("[data-subtask-name]")?.value || "").trim();
-      if (!subName) return;
-      const subTypeSel = row.querySelector("[data-subtask-type]");
-      const subMode = subTypeSel && subTypeSel.value === "asreq" ? "asreq" : "interval";
-      const subBase = {
-        id: genId(subName),
-        name: subName,
-        manualLink: "",
-        storeLink: "",
-        pn: "",
-        price: null,
-        cat: catId,
-        parentTask: id,
-        order: ++window._maintOrderCounter,
-        calendarDateISO: null
-      };
-      if (subMode === "interval"){
-        const intervalField = row.querySelector("[data-subtask-interval]");
-        let subInterval = Number(intervalField?.value);
-        if (!isFinite(subInterval) || subInterval <= 0){
-          subInterval = isFinite(parentInterval) && parentInterval > 0 ? parentInterval : 8;
-        }
-        const subTask = Object.assign({}, subBase, {
-          mode:"interval",
-          interval: subInterval,
-          sinceBase:0,
-          anchorTotal:null,
-          completedDates: [],
-          manualHistory: [],
-          variant: "template",
-          templateId: subBase.id
-        });
-        const curHours = getCurrentMachineHours();
-        const lastField = row.querySelector("[data-subtask-last]");
-        const baselineHours = parseBaselineHours(lastField?.value);
-        applyIntervalBaseline(subTask, { baselineHours, currentHours: curHours });
-        tasksInterval.unshift(subTask);
-      }else{
-        const condInput = row.querySelector("[data-subtask-condition-input]");
-        const subTask = Object.assign({}, subBase, {
-          mode:"asreq",
-          condition: (condInput?.value || "").trim() || "As required",
-          variant: "template",
-          templateId: subBase.id
-        });
-        tasksAsReq.unshift(subTask);
-      }
-    });
-
     setContextDate(calendarDateISO);
     saveCloudDebounced();
     toast(message);
     closeModal();
     renderDashboard();
     const hash = (location.hash || "#").toLowerCase();
     if (hash.startsWith("#/costs")){
       renderCosts();
     }
   });
 
-  taskExistingForm?.addEventListener("submit", (e)=>{
+  taskExistingForm?.addEventListener("submit", async (e)=>{
     e.preventDefault();
     const selectedId = existingTaskSelect?.value;
     if (!selectedId){ alert("Select a maintenance task to schedule."); return; }
     const meta = findMaintenanceTaskById(selectedId);
     if (!meta || !meta.task){
       alert("Selected maintenance task could not be found.");
       refreshExistingTaskOptions(taskExistingSearchInput?.value || "");
       return;
     }
     const task = meta.task;
+    const readiness = await ensureMaintenanceTaskReadyForCalendar(task);
+    if (!readiness.proceed){
+      if (readiness.redirected){
+        closeModal();
+        toast("Update maintenance cost and downtime before scheduling.");
+      }
+      return;
+    }
     const targetISO = addContextDateISO || ymd(new Date());
     let message = "Maintenance task added";
     if (task.mode === "interval"){
       const instance = scheduleExistingIntervalTask(task, { dateISO: targetISO }) || task;
       const parsed = parseDateLocal(targetISO);
       const todayMidnight = new Date(); todayMidnight.setHours(0,0,0,0);
       let dateLabel = targetISO;
       let completed = false;
       if (parsed instanceof Date && !Number.isNaN(parsed.getTime())){
         const display = new Date(parsed.getTime());
         dateLabel = display.toLocaleDateString();
         const compare = new Date(parsed.getTime());
         compare.setHours(0,0,0,0);
         completed = compare.getTime() <= todayMidnight.getTime();
       }
       message = completed
         ? `Logged "${instance.name || "Task"}" as completed on ${dateLabel}`
         : `Scheduled "${instance.name || "Task"}" for ${dateLabel}`;
     }else{
       task.calendarDateISO = targetISO || null;
       message = "As-required task linked from Maintenance Settings";
     }
     setContextDate(targetISO);
     saveCloudDebounced();
     toast(message);
@@ -4784,50 +4886,52 @@ function renderSettings(){
 
 
 
   // --- Normalize relationships so legacy data can't hide tasks ---
   // Tasks synced from Firestore/localStorage may still carry the
   // legacy `cat` values ("interval"/"asreq") or point at folders that
   // no longer exist. That caused the new explorer view to render an
   // empty list even though the calendar still had tasks. Running the
   // shared repair step resets any stale pointers before we render.
   if (typeof repairMaintenanceGraph === "function") {
     repairMaintenanceGraph();
   }
 
   const searchValueRaw = window.maintenanceSearchTerm || "";
   const searchTerm = searchValueRaw.trim().toLowerCase();
   const searchActive = searchTerm.length > 0;
 
   // --- Small, compact scoped styles (once) ---
   if (!document.getElementById("settingsExplorerCSS")){
     const st = document.createElement("style");
     st.id = "settingsExplorerCSS";
     st.textContent = `
       #explorer .toolbar{display:flex;flex-direction:column;align-items:center;gap:.75rem;margin-bottom:.75rem}
       #explorer .toolbar-actions{display:flex;gap:.5rem;flex-wrap:wrap;justify-content:center;width:100%}
       #explorer .toolbar-actions button{padding:.35rem .65rem;font-size:.92rem;border-radius:8px}
+      #explorer .toolbar-actions button.primary{background:#0a63c2;color:#fff}
+      #explorer .toolbar-actions button.primary:hover:not(:disabled){background:#084f9e}
       #explorer .toolbar-actions button.danger{background:#ffe7e7;color:#b00020}
       #explorer .toolbar-actions button.danger:hover:not(:disabled){background:#ffd1d1}
       #explorer .toolbar-actions button:disabled{opacity:.55;cursor:default}
       #explorer .toolbar-search{display:flex;align-items:center;gap:.45rem;justify-content:center;background:#f3f4f8;border-radius:999px;padding:.4rem .7rem;border:1px solid #d0d7e4;box-shadow:0 6px 18px rgba(15,35,72,.08);margin:0 auto;width:min(420px,100%)}
       #explorer .toolbar-search .icon{font-size:1.05rem;color:#5b6a82;display:flex;align-items:center;justify-content:center}
       #explorer .toolbar-search input{flex:1;min-width:0;padding:.2rem;border:0;background:transparent;font-size:.95rem;color:#0f1e3a}
       #explorer .toolbar-search input::placeholder{color:#8a94a8}
       #explorer .toolbar-search input:focus{outline:none}
       #explorer .toolbar-search button{padding:.32rem .7rem;font-size:.82rem;border-radius:999px;border:0;background:#eef2f8;color:#0a63c2;font-weight:600;cursor:pointer;transition:background .2s ease,color .2s ease,opacity .2s ease}
       #explorer .toolbar-search button:hover:not(:disabled){background:#e0e7f3}
       #explorer .toolbar-search button:disabled{opacity:.5;cursor:default}
       #explorer .toolbar .hint{flex:1 1 auto;text-align:center;width:100%}
       #explorer .hint{font-size:.8rem;color:#666}
       #explorer .tree{border:1px solid #e5e5e5;background:#fff;border-radius:10px;padding:6px}
       #explorer details{margin:4px 0;border:1px solid #eee;border-radius:8px;background:#fafafa}
       #explorer details>summary{position:relative;display:flex;align-items:center;gap:8px;padding:6px 8px;cursor:grab;user-select:none}
       #explorer details.task>summary{background:#fff;font-weight:600;border-bottom:1px solid #ececec}
       #explorer details.cat>summary{font-weight:700;background:#f4f6fb}
       #explorer .task-name{flex:1;min-width:0}
       #explorer summary .chip{font-size:.72rem;border:1px solid #bbb;border-radius:999px;padding:.05rem .45rem;background:#fff}
       #explorer .body{padding:8px 10px;background:#fff;border-top:1px dashed #e5e5e5}
       #explorer .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.5rem}
       #explorer label{font-size:.85rem;display:flex;flex-direction:column;gap:4px}
       #explorer input,#explorer select,#explorer textarea{width:100%;padding:.35rem .45rem;border:1px solid #ccd4e0;border-radius:6px;font-size:.9rem}
       #explorer textarea{min-height:70px;resize:vertical}
@@ -5203,50 +5307,51 @@ function renderSettings(){
       emptyMessage: emptySubMsg,
       emptyClass: "sub-empty",
       emptyAttrs: `data-empty-sub="${t.id}"`
     });
     return `
       <details class="task task--${type}" data-task-id="${t.id}" data-owner="${type}">
         <summary draggable="true">
           <span class="task-name">${name}</span>
           <span class="chip">${type === "interval" ? "By Interval" : "As Required"}</span>
           ${type === "interval" ? `<span class=\"chip\" data-chip-frequency="${t.id}">${escapeHtml(freq)}</span>` : `<span class=\"chip\" data-chip-condition="${t.id}">${condition}</span>`}
           ${type === "interval" ? dueChip(t) : ""}
         </summary>
         <div class="body">
           <div class="grid">
             <label>Task name<input data-k="name" data-id="${t.id}" data-list="${type}" value="${escapeHtml(t.name||"")}" placeholder="Name"></label>
             <label>Type<select data-k="mode" data-id="${t.id}" data-list="${type}">
               <option value="interval" ${type==="interval"?"selected":""}>By interval</option>
               <option value="asreq" ${type==="asreq"?"selected":""}>As required</option>
             </select></label>
             ${type === "interval" ? `<label>Frequency (hrs)<input type=\"number\" min=\"1\" step=\"1\" data-k=\"interval\" data-id=\"${t.id}\" data-list=\"interval\" value=\"${t.interval!=null?t.interval:""}\" placeholder=\"Hours between service\"></label>` : `<label>Condition / trigger<input data-k=\"condition\" data-id=\"${t.id}\" data-list=\"asreq\" value=\"${escapeHtml(t.condition||"")}\" placeholder=\"When to perform\"></label>`}
             ${type === "interval" ? `<label>Hours since last service<input type=\"number\" min=\"0\" step=\"0.01\" data-k=\"sinceBase\" data-id=\"${t.id}\" data-list=\"interval\" value=\"${baselineVal!==""?baselineVal:""}\" placeholder=\"optional\"></label>` : ""}
             <label>Manual link<input type="url" data-k="manualLink" data-id="${t.id}" data-list="${type}" value="${escapeHtml(t.manualLink||"")}" placeholder="https://..."></label>
             <label>Store link<input type="url" data-k="storeLink" data-id="${t.id}" data-list="${type}" value="${escapeHtml(t.storeLink||"")}" placeholder="https://..."></label>
             <label>Part #<input data-k="pn" data-id="${t.id}" data-list="${type}" value="${escapeHtml(t.pn||"")}" placeholder="Part number"></label>
             <label>Price ($)<input type="number" step="0.01" min="0" data-k="price" data-id="${t.id}" data-list="${type}" value="${t.price!=null?t.price:""}" placeholder="optional"></label>
+            <label>Down time (hrs)<input type="number" step="0.25" min="0" data-k="downtimeHours" data-id="${t.id}" data-list="${type}" value="${(typeof readTaskDowntimeHours === "function" ? (readTaskDowntimeHours(t) ?? "") : (Number.isFinite(Number(t?.downtimeHours)) && Number(t.downtimeHours) >= 0 ? Number(t.downtimeHours) : ""))}" placeholder="optional"></label>
             <label class="task-note">Note<textarea data-k="note" data-id="${t.id}" data-list="${type}" rows="2" placeholder="Optional note">${escapeHtml(t.note||"")}</textarea></label>
           </div>
           <div class="row-actions">
             ${type === "interval" ? `<button class="btn-complete" data-complete="${t.id}">Mark completed now</button>` : ""}
             <button class="danger" data-remove="${t.id}" data-from="${type}">Remove</button>
           </div>
         </div>
         <div class="task-children" data-task-children="${t.id}">
           <div class="dz" data-drop-into-task="${t.id}" data-label="Create sub-task"></div>
           ${childList}
         </div>
       </details>
     `;
   }
 
   function renderMixedList(catId, options = {}){
     const {
       taskGapLabel = "Move item here",
       tailLabel = "Move item here",
       catGapLabel = "Move category here",
       emptyMessage = "",
       emptyClass = "empty",
       emptyAttrs = ""
     } = options;
     const catKey = String(catId ?? "");
@@ -5327,50 +5432,51 @@ function renderSettings(){
     taskGapLabel: "Move item here",
     tailLabel: "Move item here",
     catGapLabel: "Move category here"
   });
 
   const flattenedFolders = [];
   (function walk(parent, prefix){
     for (const f of childrenFolders(parent)){
       flattenedFolders.push({ id: f.id, label: `${prefix}${f.name}` });
       walk(f.id, `${prefix}${f.name} / `);
     }
   })(null, "");
 
   const categoryOptions = ["<option value=\"\">(No Category)</option>"]
     .concat(flattenedFolders.map(f => `<option value=\"${f.id}\">${escapeHtml(f.label)}</option>`))
     .join("");
 
   root.innerHTML = `
     <div id="explorer" class="container">
       <div class="block" style="grid-column:1 / -1">
         <h3>Maintenance Settings</h3>
         <div class="toolbar">
           <div class="toolbar-actions">
             <button id="btnAddCategory">+ Add Category</button>
             <button id="btnAddTask">+ Add Task</button>
+            <button id="saveMaintenanceTasksBtn" class="primary" title="Save maintenance tasks">Save changes</button>
             <button id="btnClearAllDataInline" class="danger" data-clear-all="1" title="Reset all maintenance data">🧹 Clear All Data</button>
           </div>
           <div class="toolbar-search">
             <span class="icon" aria-hidden="true">🔍</span>
             <input type="search" id="maintenanceSearch" placeholder="Search tasks, parts, or links" value="${escapeHtml(searchValueRaw)}" aria-label="Search maintenance tasks" autocomplete="off">
             <button type="button" id="maintenanceSearchClear" ${searchValueRaw ? "" : "disabled"}>Clear</button>
           </div>
           <span class="hint">Drag folders & tasks to organize. Tasks can hold sub-tasks like folders.</span>
         </div>
         <div class="tree" id="tree">
           <div class="dz" data-drop-root="1" data-label="Move to top level"></div>
           ${mixedRoot}
           ${searchEmpty ? `<div class="empty">No maintenance tasks match your search.</div>` : ``}
           ${(window.settingsFolders.length === 0 && window.tasksInterval.length + window.tasksAsReq.length === 0) ? `<div class="empty">No tasks yet. Add one to get started.</div>` : ``}
         </div>
       </div>
     </div>
     <div class="modal-backdrop" id="taskModal" hidden>
       <div class="modal-card">
         <button type="button" class="modal-close" id="closeTaskModal">×</button>
         <h4>Create maintenance task</h4>
         <form id="taskForm" class="modal-form">
           <div class="modal-grid">
             <label>Task name<input name="taskName" required placeholder="Task"></label>
             <label>Type<select name="taskType" id="taskTypeSelect">
@@ -5388,50 +5494,51 @@ function renderSettings(){
             <label>Category<select name="taskCategory">${categoryOptions}</select></label>
           </div>
           <div class="modal-actions">
             <button type="button" class="secondary" id="cancelTaskModal">Cancel</button>
             <button type="submit" class="primary">Create Task</button>
           </div>
         </form>
       </div>
     </div>
     <div id="maintenanceContextMenu" class="context-menu" hidden>
       <button type="button" data-action="edit">Edit</button>
       <button type="button" class="danger" data-action="delete">Delete</button>
     </div>
   `;
 
   const tree = document.getElementById("tree");
   const modal = document.getElementById("taskModal");
   const form = document.getElementById("taskForm");
   const typeField = document.getElementById("taskTypeSelect");
   const freqRow = form?.querySelector('[data-form-frequency]');
   const lastRow = form?.querySelector('[data-form-last]');
   const conditionRow = form?.querySelector('[data-form-condition]');
   const searchInput = document.getElementById("maintenanceSearch");
   const searchClear = document.getElementById("maintenanceSearchClear");
   const contextMenu = document.getElementById("maintenanceContextMenu");
+  const saveBtn = document.getElementById("saveMaintenanceTasksBtn");
   let contextTarget = null;
 
   const promptRemoveLinkedInventory = async (task, matches)=>{
     const list = Array.isArray(matches) ? matches.filter(Boolean) : [];
     const taskLabel = task && task.name ? `"${task.name}"` : "this task";
     if (!list.length){
       const confirmed = await showConfirmModal({
         title: "Remove maintenance task?",
         message: `Delete ${taskLabel}? This will remove it from every page.`,
         cancelText: "Cancel",
         confirmText: "Delete task",
         confirmVariant: "danger"
       });
       return confirmed ? "task" : "cancel";
     }
 
     const count = list.length;
     const baseMessage = count === 1
       ? `Delete ${taskLabel}? It's linked to the inventory item below.`
       : `Delete ${taskLabel}? It's linked to these ${count} inventory items.`;
     const choice = await showConfirmChoices({
       title: "Remove maintenance task?",
       message: `${baseMessage} Choose what to delete.`,
       items: list.map(item => item && item.name ? item.name : "Unnamed inventory item"),
       cancelText: "Cancel",
@@ -5542,50 +5649,79 @@ function renderSettings(){
         if (!nextInput) return;
         const end = nextInput.value.length;
         nextInput.focus();
         if (typeof nextInput.setSelectionRange === "function"){
           nextInput.setSelectionRange(end, end);
         }
       }, 0);
     });
   }
 
   if (searchClear){
     searchClear.addEventListener("click", ()=>{
       if (!window.maintenanceSearchTerm){
         searchInput?.focus();
         return;
       }
       window.maintenanceSearchTerm = "";
       renderSettings();
       setTimeout(()=>{
         const nextInput = document.getElementById("maintenanceSearch");
         nextInput?.focus();
       }, 0);
     });
   }
 
+  if (saveBtn){
+    saveBtn.addEventListener("click", ()=>{
+      persist();
+      let broadcasted = false;
+      if (typeof broadcastMaintenanceTasksUpdated === "function"){
+        try {
+          broadcastMaintenanceTasksUpdated({ source: "maintenance-settings-save" });
+          broadcasted = true;
+        } catch (err) {
+          console.warn("Failed to broadcast maintenance task save", err);
+        }
+      }
+      if (!broadcasted){
+        try { if (typeof renderCalendar === "function") renderCalendar(); }
+        catch (err) { console.warn("Failed to refresh calendar after save", err); }
+        try { if (typeof renderDashboard === "function") renderDashboard(); }
+        catch (err) { console.warn("Failed to refresh dashboard after save", err); }
+        if (typeof renderCosts === "function"){
+          const hash = (location.hash || "#").toLowerCase();
+          if (hash === "#/costs" || hash === "#costs"){
+            try { renderCosts(); }
+            catch (err) { console.warn("Failed to refresh costs after save", err); }
+          }
+        }
+      }
+      toast("Maintenance tasks saved");
+    });
+  }
+
   const persist = ()=>{
     if (typeof setSettingsFolders === "function") {
       try { setSettingsFolders(window.settingsFolders); } catch (err) {
         console.warn("Failed to sync folders before save", err);
       }
     }
     if (typeof saveTasks === "function") { try{ saveTasks(); }catch(_){} }
     if (typeof saveCloudDebounced === "function") { try{ saveCloudDebounced(); }catch(_){} }
   };
 
   async function promptAddTaskToInventory(task){
     if (!task) return;
     const label = task.name ? `"${task.name}"` : "this task";
     const matchesRaw = findInventoryMatchesForTask(task);
     const matches = Array.isArray(matchesRaw) ? matchesRaw.slice() : [];
     matches.sort((a, b)=>{
       const aScore = (a && String(a.id) === String(task.inventoryId)) ? 3
         : (a && String(a.linkedTaskId || "") === String(task.id)) ? 2
         : 1;
       const bScore = (b && String(b.id) === String(task.inventoryId)) ? 3
         : (b && String(b.linkedTaskId || "") === String(task.id)) ? 2
         : 1;
       if (bScore !== aScore) return bScore - aScore;
       const aName = a && a.name ? a.name : "";
       const bName = b && b.name ? b.name : "";
@@ -5934,81 +6070,83 @@ function renderSettings(){
     const chip = holder.querySelector('[data-due-chip]');
     if (!chip) return;
     chip.textContent = "";
     chip.classList.remove("due-ok","due-warn","due-soon","due-late");
     if (typeof nextDue !== "function"){ chip.textContent = "—"; return; }
     const nd = nextDue(task);
     if (!nd){ chip.textContent = "Awaiting usage data"; chip.classList.add("due-warn"); return; }
     chip.textContent = `${nd.days}d → ${nd.due.toDateString()}`;
     if (nd.days <= 1) chip.classList.add("due-late");
     else if (nd.days <= 3) chip.classList.add("due-soon");
     else if (nd.days <= 7) chip.classList.add("due-warn");
     else chip.classList.add("due-ok");
   }
 
   tree?.addEventListener("input", (e)=>{
     const target = e.target;
     if (!(target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement)) return;
     const holder = target.closest("[data-task-id]");
     if (!holder) return;
     const id = holder.getAttribute("data-task-id");
     const meta = findTaskMeta(id);
     if (!meta) return;
     const key = target.getAttribute("data-k");
     if (!key || key === "mode") return;
     let value = target.value;
-    if (key === "price" || key === "interval" || key === "anchorTotal" || key === "sinceBase"){
+    if (key === "price" || key === "interval" || key === "anchorTotal" || key === "sinceBase" || key === "downtimeHours"){
       value = value === "" ? null : Number(value);
       if (value !== null && !isFinite(value)) return;
     }
     if (key === "interval"){
       meta.task.interval = value == null ? null : Number(value);
       const chip = holder.querySelector('[data-chip-frequency]');
       if (chip) chip.textContent = meta.task.interval ? `${meta.task.interval} hrs` : "Set frequency";
       updateDueChip(holder, meta.task);
     }else if (key === "anchorTotal"){
       if (value == null){
         meta.task.anchorTotal = null;
         meta.task.sinceBase = null;
       }else{
         const base = Math.max(0, Number(value));
         meta.task.sinceBase = base;
         applyIntervalBaseline(meta.task, { baselineHours: base });
       }
       updateDueChip(holder, meta.task);
     }else if (key === "sinceBase"){
       if (value == null){
         meta.task.sinceBase = null;
         meta.task.anchorTotal = null;
       }else{
         const base = Math.max(0, Number(value));
         meta.task.sinceBase = base;
         applyIntervalBaseline(meta.task, { baselineHours: base });
       }
       updateDueChip(holder, meta.task);
     }else if (key === "price"){
       meta.task.price = value == null ? null : Number(value);
+    }else if (key === "downtimeHours"){
+      meta.task.downtimeHours = value == null ? null : Math.max(0, Number(value));
     }else if (key === "manualLink" || key === "storeLink" || key === "pn" || key === "name" || key === "condition" || key === "note"){
       meta.task[key] = target.value;
       if (key === "name"){ const label = holder.querySelector('.task-name'); if (label) label.textContent = target.value || "(unnamed task)"; }
       if (key === "condition"){ const chip = holder.querySelector('[data-chip-condition]'); if (chip) chip.textContent = target.value || "As required"; }
     }
     persist();
   });
 
   tree?.addEventListener("change", (e)=>{
     const target = e.target;
     if (!(target instanceof HTMLSelectElement)) return;
     const holder = target.closest("[data-task-id]");
     if (!holder) return;
     const id = holder.getAttribute("data-task-id");
     const meta = findTaskMeta(id);
     if (!meta) return;
     if (target.getAttribute("data-k") === "mode"){
       const nextMode = target.value;
       if (nextMode === meta.mode) return;
       meta.list.splice(meta.index,1);
       if (nextMode === "interval"){
         meta.task.mode = "interval";
         meta.task.interval = meta.task.interval && meta.task.interval>0 ? Number(meta.task.interval) : 8;
         const baseSince = Number(meta.task.sinceBase);
         const baselineHours = Number.isFinite(baseSince) && baseSince >= 0 ? baseSince : 0;
@@ -6369,50 +6507,213 @@ function renderSettings(){
       if (dzRoot){
         if (typeof moveNodeSafely === 'function' && moveNodeSafely('category', id, { intoCat: null, position: 'start' })){
           persist();
           renderSettings();
         }
         return;
       }
       if (onCatSummary){
         const beforeId = onCatSummary.closest('details.cat')?.getAttribute('data-cat-id');
         if (beforeId && typeof moveNodeSafely === 'function' && moveNodeSafely('category', id, { beforeCat: { id: beforeId } })){
           persist();
           renderSettings();
         }
         return;
       }
     }
   });
 }
 
 // ---- Costs page ----
 const COST_CHART_COLORS = {
   maintenance: "#0a63c2",
   jobs: "#2e7d32"
 };
 
+function collectMaintenanceEventsForCost(options = {}){
+  const monthsAhead = Number.isFinite(Number(options.monthsAhead)) && Number(options.monthsAhead) > 0
+    ? Number(options.monthsAhead)
+    : 12;
+  const statusPriority = { completed: 3, manual: 2, due: 1 };
+  const eventsByDate = new Map();
+
+  const resolveDowntime = (task)=>{
+    if (typeof readTaskDowntimeHours === "function"){
+      const val = readTaskDowntimeHours(task);
+      if (val == null) return 0;
+      return Number.isFinite(val) && val >= 0 ? val : 0;
+    }
+    const raw = Number(task?.downtimeHours);
+    return Number.isFinite(raw) && raw >= 0 ? raw : 0;
+  };
+
+  const resolvePrice = (task)=>{
+    if (typeof readTaskMaintenanceCost === "function"){
+      const total = readTaskMaintenanceCost(task);
+      if (Number.isFinite(total) && total > 0) return total;
+    }
+    let total = 0;
+    const raw = Number(task?.price);
+    if (Number.isFinite(raw) && raw > 0) total += raw;
+    const parts = Array.isArray(task?.parts) ? task.parts : [];
+    for (const part of parts){
+      const partPrice = Number(part?.price);
+      if (Number.isFinite(partPrice) && partPrice > 0){
+        total += partPrice;
+      }
+    }
+    return total;
+  };
+
+  const pushEvent = (task, iso, status)=>{
+    if (!task || !iso) return;
+    const key = normalizeDateKey(iso);
+    if (!key) return;
+    const id = String(task.id);
+    if (!id) return;
+    const statusKey = status || "due";
+    const downtimeHours = resolveDowntime(task);
+    const price = resolvePrice(task);
+    const list = eventsByDate.get(key) || [];
+    const current = list.find(ev => ev.id === id);
+    if (current){
+      const existingPriority = statusPriority[current.status] || 1;
+      const nextPriority = statusPriority[statusKey] || 1;
+      if (nextPriority >= existingPriority){
+        current.status = statusKey;
+      }
+      current.downtimeHours = downtimeHours;
+      current.price = price;
+    }else{
+      list.push({
+        id,
+        status: statusKey,
+        mode: task && task.mode === "asreq" ? "asreq" : "interval",
+        downtimeHours,
+        price,
+        dateISO: key
+      });
+    }
+    eventsByDate.set(key, list);
+  };
+
+  const intervalTasks = Array.isArray(window.tasksInterval)
+    ? window.tasksInterval.filter(t => t && t.mode === "interval" && isInstanceTask(t))
+    : [];
+  const completedByTask = new Map();
+  intervalTasks.forEach(t => {
+    if (!t) return;
+    const rawDates = Array.isArray(t.completedDates) ? t.completedDates : [];
+    const set = new Set();
+    rawDates.map(normalizeDateKey).filter(Boolean).forEach(key => set.add(key));
+    completedByTask.set(String(t.id), set);
+  });
+  intervalTasks.forEach(t => {
+    if (!t) return;
+    const taskKey = String(t.id);
+    let completedKeys = completedByTask.get(taskKey);
+    if (!(completedKeys instanceof Set)){
+      completedKeys = new Set();
+      completedByTask.set(taskKey, completedKeys);
+    }
+    completedKeys.forEach(dateKey => {
+      if (!dateKey) return;
+      pushEvent(t, dateKey, "completed");
+    });
+
+    const manualHistory = typeof ensureTaskManualHistory === "function"
+      ? ensureTaskManualHistory(t)
+      : (Array.isArray(t.manualHistory) ? t.manualHistory : []);
+    const manualDates = new Set();
+    manualHistory.forEach(entry => {
+      if (!entry) return;
+      const entryKey = normalizeDateKey(entry.dateISO);
+      if (!entryKey) return;
+      const entryStatus = entry.status || "logged";
+      if (entryStatus === "completed"){
+        if (!completedKeys.has(entryKey)){
+          completedKeys.add(entryKey);
+          pushEvent(t, entryKey, "completed");
+        }
+        return;
+      }
+      manualDates.add(entryKey);
+    });
+
+    const manualKey = normalizeDateKey(t.calendarDateISO);
+    if (manualKey) manualDates.add(manualKey);
+
+    manualDates.forEach(dateKey => {
+      if (!dateKey) return;
+      if (completedKeys.has(dateKey)) return;
+      pushEvent(t, dateKey, "manual");
+    });
+
+    const skipDates = new Set(completedKeys);
+    manualDates.forEach(dateKey => skipDates.add(dateKey));
+    const projections = projectIntervalDueDates(t, {
+      monthsAhead,
+      excludeDates: skipDates,
+      minOccurrences: 6
+    });
+    if (Array.isArray(projections) && projections.length){
+      projections.forEach(pred => {
+        const dueKey = normalizeDateKey(pred?.dateISO);
+        if (!dueKey) return;
+        if (completedKeys.has(dueKey)) return;
+        if (manualKey && manualKey === dueKey && !completedKeys.has(dueKey)) return;
+        pushEvent(t, dueKey, "due");
+      });
+      return;
+    }
+
+    const nd = nextDue(t);
+    if (!nd) return;
+    const dueKey = normalizeDateKey(nd.due);
+    if (!dueKey) return;
+    if (completedKeys.has(dueKey)) return;
+    if (!manualKey || manualKey !== dueKey){
+      pushEvent(t, dueKey, "due");
+    }
+  });
+
+  const asReqTasks = Array.isArray(window.tasksAsReq) ? window.tasksAsReq : [];
+  asReqTasks.forEach(t => {
+    if (!t) return;
+    const completedDates = new Set(Array.isArray(t.completedDates) ? t.completedDates.map(normalizeDateKey).filter(Boolean) : []);
+    completedDates.forEach(dateKey => {
+      if (dateKey) pushEvent(t, dateKey, "completed");
+    });
+    const manualKey = normalizeDateKey(t.calendarDateISO);
+    if (manualKey){
+      pushEvent(t, manualKey, completedDates.has(manualKey) ? "completed" : "manual");
+    }
+  });
+
+  return eventsByDate;
+}
+
 function resizeCostChartCanvas(canvas){
   if (!canvas) return;
   const parent = canvas.parentElement;
   if (!parent) return;
   const rect = parent.getBoundingClientRect();
   const fallbackWidth = canvas.width || 720;
   const rawWidth = rect.width || parent.clientWidth || fallbackWidth;
   const width = Math.max(360, Math.round(rawWidth || fallbackWidth));
   const ratio = 240 / 780; // original aspect ratio ~0.3077
   const minHeight = 220;
   const height = Math.max(minHeight, Math.round(width * ratio));
   if (canvas.width !== width) canvas.width = width;
   if (canvas.height !== height) canvas.height = height;
 }
 
 const costChartAutoResizeState = {
   observer: null,
   layoutHandler: null,
   pendingFrame: null,
   observedWrap: null,
   observedCanvas: null,
   lastWrapWidth: null,
   lastWrapHeight: null
 };
 
@@ -7135,50 +7436,67 @@ function renderCosts(){
     historyList.addEventListener("click", (event)=>{
       const deleteBtn = (event.target instanceof HTMLElement) ? event.target.closest("[data-history-delete]") : null;
       if (deleteBtn){
         const item = resolveItem(deleteBtn);
         if (!item) return;
         event.preventDefault();
         event.stopPropagation();
         remove(item);
         return;
       }
       const item = resolveItem(event.target);
       if (!item) return;
       event.preventDefault();
       activate(item);
     });
     historyList.addEventListener("keydown", (event)=>{
       if (event.repeat) return;
       if (event.key !== "Enter" && event.key !== " " && event.key !== "Spacebar") return;
       const item = resolveItem(event.target);
       if (!item) return;
       event.preventDefault();
       activate(item);
     });
   }
 
+  const downtimeRateBtn = content.querySelector("[data-edit-downtime-rate]");
+  if (downtimeRateBtn){
+    downtimeRateBtn.addEventListener("click", ()=>{
+      const current = Number(window.downtimeBaseLossRate);
+      const promptValue = window.prompt("Set fallback downtime loss rate ($/hr)", Number.isFinite(current) && current >= 0 ? String(current) : "150");
+      if (promptValue == null) return;
+      const parsed = Number(promptValue);
+      if (!Number.isFinite(parsed) || parsed < 0){
+        window.alert("Enter a non-negative loss rate.");
+        return;
+      }
+      window.downtimeBaseLossRate = parsed;
+      if (typeof saveCloudDebounced === "function"){ try { saveCloudDebounced(); } catch(_){} }
+      renderCosts();
+    });
+  }
+
   const canvas = document.getElementById("costChart");
   const toggleMaint = document.getElementById("toggleCostMaintenance");
   const toggleJobs  = document.getElementById("toggleCostJobs");
   const canvasWrap = content.querySelector(".cost-chart-canvas");
   let tooltipEl = canvasWrap ? canvasWrap.querySelector(".cost-chart-tooltip") : null;
 
   const escapeTooltip = (value)=> String(value ?? "").replace(/[&<>"']/g, c => ({
     "&": "&amp;",
     "<": "&lt;",
     ">": "&gt;",
     '"': "&quot;",
     "'": "&#39;"
   })[c] || c);
 
   const ensureTooltip = ()=>{
     if (!canvasWrap) return null;
     if (!tooltipEl){
       tooltipEl = document.createElement("div");
       tooltipEl.className = "cost-chart-tooltip";
       tooltipEl.setAttribute("role", "tooltip");
       tooltipEl.hidden = true;
       canvasWrap.appendChild(tooltipEl);
     }
     return tooltipEl;
   };
@@ -7958,50 +8276,143 @@ function computeCostModel(){
   }
 
   const jobSeriesSorted = jobSeriesRaw.slice().sort((a,b)=> a.date - b.date);
   const jobSeries = [];
   if (jobSeriesSorted.length){
     let cumulative = 0;
     jobSeriesSorted.forEach((pt, idx)=>{
       cumulative += pt.rawValue;
       const rollingValue = cumulative / (idx + 1);
       const dateLabel = (pt.date instanceof Date && !Number.isNaN(pt.date.getTime()))
         ? pt.date.toLocaleDateString(undefined, { month: "short", day: "numeric", year: "numeric" })
         : "the latest completed job";
       const jobCount = idx + 1;
       jobSeries.push({
         date: pt.date,
         value: rollingValue,
         count: jobCount,
         detail: `Rolling average profit per cutting job across ${jobCount} completed job${jobCount === 1 ? "" : "s"} through ${dateLabel}.`
       });
     });
   }
 
   const jobCount = completedCount;
   const averageGainLoss = jobCount ? (totalGainLoss / jobCount) : 0;
 
+  const downtimeBaseRateRaw = Number(window.downtimeBaseLossRate);
+  const downtimeBaseRate = Number.isFinite(downtimeBaseRateRaw) && downtimeBaseRateRaw >= 0 ? downtimeBaseRateRaw : 150;
+  const jobRateByDate = new Map();
+  if (Array.isArray(cuttingJobs)){
+    cuttingJobs.forEach(job => {
+      if (!job) return;
+      let netRate = null;
+      if (typeof computeJobEfficiency === "function"){
+        try {
+          const eff = computeJobEfficiency(job);
+          if (eff && typeof eff.netRate === "number") netRate = Number(eff.netRate);
+        } catch (err){
+          netRate = null;
+        }
+      }
+      if (!Number.isFinite(netRate)){
+        const fallbackRate = Number(job?.netRate);
+        if (Number.isFinite(fallbackRate)) netRate = fallbackRate;
+      }
+      if (!Number.isFinite(netRate) || netRate <= 0) return;
+      const start = parseDateLocal(job.startISO);
+      const end = parseDateLocal(job.dueISO);
+      if (!start || !end) return;
+      start.setHours(0,0,0,0);
+      end.setHours(0,0,0,0);
+      const cursor = new Date(start.getTime());
+      while (cursor <= end){
+        const key = ymd(cursor);
+        jobRateByDate.set(key, (jobRateByDate.get(key) || 0) + netRate);
+        cursor.setDate(cursor.getDate() + 1);
+      }
+    });
+  }
+
+  const maintenanceEventsMap = typeof collectMaintenanceEventsForCost === "function"
+    ? collectMaintenanceEventsForCost({ monthsAhead: 12 })
+    : new Map();
+  const downtimeDailyRaw = [];
+  const today = new Date();
+  today.setHours(0,0,0,0);
+  maintenanceEventsMap.forEach((events, dateISO) => {
+    if (!Array.isArray(events) || !events.length) return;
+    const parsed = parseDateLocal(dateISO) || new Date(`${dateISO}T00:00:00`);
+    if (!(parsed instanceof Date) || Number.isNaN(parsed.getTime())) return;
+    parsed.setHours(0,0,0,0);
+    let actualTaskCost = 0;
+    let projectedTaskCost = 0;
+    let actualHours = 0;
+    let projectedHours = 0;
+    events.forEach(ev => {
+      const price = Number(ev?.price);
+      const downtimeHours = Number(ev?.downtimeHours);
+      const safePrice = Number.isFinite(price) && price > 0 ? price : 0;
+      const safeHours = Number.isFinite(downtimeHours) && downtimeHours > 0 ? downtimeHours : 0;
+      if (ev && ev.status === "completed"){
+        actualTaskCost += safePrice;
+        actualHours += safeHours;
+      }else{
+        projectedTaskCost += safePrice;
+        projectedHours += safeHours;
+      }
+    });
+    if (actualTaskCost === 0 && projectedTaskCost === 0 && actualHours === 0 && projectedHours === 0) return;
+    const dateKey = dateISO;
+    const jobRate = jobRateByDate.get(dateKey) || 0;
+    const rate = jobRate > 0 ? jobRate : downtimeBaseRate;
+    const actualDowntimeLoss = actualHours > 0 ? actualHours * rate : 0;
+    const projectedDowntimeLoss = projectedHours > 0 ? projectedHours * rate : 0;
+    downtimeDailyRaw.push({
+      dateISO: dateKey,
+      date: parsed,
+      rate,
+      actualTaskCost,
+      projectedTaskCost,
+      actualHours,
+      projectedHours,
+      actualDowntimeLoss,
+      projectedDowntimeLoss,
+      actualTotal: actualTaskCost + actualDowntimeLoss,
+      projectedTotal: projectedTaskCost + projectedDowntimeLoss
+    });
+  });
+  downtimeDailyRaw.sort((a,b)=> (a.date?.getTime() || 0) - (b.date?.getTime() || 0));
+
+  const downtimeTimeframes = [
+    { key: "day", label: "1 day", days: 1 },
+    { key: "week", label: "1 week", days: 7 },
+    { key: "month", label: "1 month", days: 30 },
+    { key: "quarter", label: "3 months", days: 90 },
+    { key: "half", label: "6 months", days: 182 },
+    { key: "year", label: "1 year", days: 365 }
+  ];
+
   const formatterCurrency = (value, { showPlus=false, decimals=null } = {})=>{
     const absVal = Math.abs(value);
     const fractionDigits = decimals != null ? decimals : (absVal < 1000 ? 2 : 0);
     const formatted = new Intl.NumberFormat(undefined, {
       style: "currency",
       currency: "USD",
       minimumFractionDigits: fractionDigits,
       maximumFractionDigits: fractionDigits
     }).format(absVal);
     if (value < 0) return `-${formatted}`;
     if (value > 0 && showPlus) return `+${formatted}`;
     return formatted;
   };
 
   const formatHours = (hours)=>{
     if (!isFinite(hours) || hours <= 0) return "0 hr";
     const decimals = hours >= 100 ? 0 : 1;
     return `${hours.toFixed(decimals)} hr`;
   };
 
   const formatCount = (value)=>{
     if (!isFinite(value) || value <= 0) return null;
     const abs = Math.abs(value);
     let decimals = 2;
     if (abs >= 100) decimals = 0;
@@ -8011,50 +8422,126 @@ function computeCostModel(){
       minimumFractionDigits: 0,
       maximumFractionDigits: decimals
     });
   };
 
   const formatHoursValue = (value)=>{
     if (!isFinite(value) || value <= 0) return null;
     const abs = Math.abs(value);
     let decimals = 0;
     if (abs < 10) decimals = 1;
     const rounded = Number(value.toFixed(decimals));
     return rounded.toLocaleString(undefined, {
       minimumFractionDigits: decimals,
       maximumFractionDigits: decimals
     });
   };
 
   const timeframeRows = timeframeRowsRaw.map(row => ({
     key: row.key,
     label: row.label,
     hoursLabel: formatHours(row.hours),
     costLabel: formatterCurrency(row.costActual, { decimals: row.costActual < 1000 ? 2 : 0 }),
     projectedLabel: formatterCurrency(row.costProjected, { decimals: row.costProjected < 1000 ? 2 : 0 })
   }));
 
+  const todayTime = today.getTime();
+  const downtimeRowsRaw = downtimeTimeframes.map(frame => {
+    const actualStart = new Date(today);
+    actualStart.setDate(today.getDate() - (frame.days - 1));
+    const projectedEnd = new Date(today);
+    projectedEnd.setDate(today.getDate() + (frame.days - 1));
+    const actualStartTime = actualStart.getTime();
+    const projectedEndTime = projectedEnd.getTime();
+    let actualTotal = 0;
+    let projectedTotal = 0;
+    let actualHours = 0;
+    let projectedHours = 0;
+    let actualTaskCost = 0;
+    let projectedTaskCost = 0;
+    let actualDowntimeLoss = 0;
+    let projectedDowntimeLoss = 0;
+    downtimeDailyRaw.forEach(entry => {
+      const entryTime = entry.date instanceof Date ? entry.date.getTime() : null;
+      if (entryTime == null) return;
+      if (entryTime >= actualStartTime && entryTime <= todayTime){
+        actualTotal += entry.actualTotal;
+        actualHours += Number(entry.actualHours) || 0;
+        actualTaskCost += Number(entry.actualTaskCost) || 0;
+        actualDowntimeLoss += Number(entry.actualDowntimeLoss) || 0;
+      }
+      if (entryTime >= todayTime && entryTime <= projectedEndTime){
+        projectedTotal += entry.projectedTotal;
+        projectedHours += Number(entry.projectedHours) || 0;
+        projectedTaskCost += Number(entry.projectedTaskCost) || 0;
+        projectedDowntimeLoss += Number(entry.projectedDowntimeLoss) || 0;
+      }
+    });
+    return {
+      key: frame.key,
+      label: frame.label,
+      days: frame.days,
+      actualTotal,
+      projectedTotal,
+      actualHours,
+      projectedHours,
+      actualTaskCost,
+      projectedTaskCost,
+      actualDowntimeLoss,
+      projectedDowntimeLoss
+    };
+  });
+
+  const downtimeRows = downtimeRowsRaw.map(row => ({
+    key: row.key,
+    label: row.label,
+    actualValue: row.actualTotal,
+    projectedValue: row.projectedTotal,
+    actualHours: row.actualHours,
+    projectedHours: row.projectedHours,
+    actualTaskCost: row.actualTaskCost,
+    projectedTaskCost: row.projectedTaskCost,
+    actualDowntimeLoss: row.actualDowntimeLoss,
+    projectedDowntimeLoss: row.projectedDowntimeLoss,
+    actualLabel: formatterCurrency(row.actualTotal, { decimals: row.actualTotal < 1000 ? 2 : 0 }),
+    projectedLabel: formatterCurrency(row.projectedTotal, { decimals: row.projectedTotal < 1000 ? 2 : 0 })
+  }));
+
+  const downtimeBaseRateLabel = `${formatterCurrency(downtimeBaseRate, { decimals: downtimeBaseRate < 1000 ? 2 : 0 })}/hr`;
+  const downtimeDailyEntries = downtimeDailyRaw.map(entry => ({
+    dateISO: entry.dateISO,
+    rate: entry.rate,
+    actualHours: entry.actualHours,
+    projectedHours: entry.projectedHours,
+    actualTaskCost: entry.actualTaskCost,
+    projectedTaskCost: entry.projectedTaskCost,
+    actualDowntimeLoss: entry.actualDowntimeLoss,
+    projectedDowntimeLoss: entry.projectedDowntimeLoss,
+    actualTotal: entry.actualTotal,
+    projectedTotal: entry.projectedTotal
+  }));
+
   const intervalAnnualBasis = baselineAnnualHours > 0
     ? baselineAnnualHours
     : (hoursYear > 0 ? hoursYear : 0);
 
   const intervalTaskRowsRaw = intervalTasks.map((task, index) => {
     const name = task?.name || `Interval task ${index + 1}`;
     const intervalHours = Number(task?.interval);
     const price = Number(task?.price);
     const hasPrice = Number.isFinite(price) && price > 0;
     const hasInterval = Number.isFinite(intervalHours) && intervalHours > 0;
     const servicesPerYear = (intervalAnnualBasis > 0 && hasInterval)
       ? intervalAnnualBasis / intervalHours
       : 0;
     const intervalLabel = hasInterval ? formatHoursValue(intervalHours) : null;
     const servicesLabel = formatCount(servicesPerYear);
     const cadenceParts = [];
     if (intervalLabel) cadenceParts.push(`Every ${intervalLabel} hr`);
     if (servicesLabel) cadenceParts.push(`~${servicesLabel}×/yr`);
     if (!cadenceParts.length && task?.condition){
       cadenceParts.push(String(task.condition));
     }
     const annualCost = hasPrice ? Math.max(0, price * Math.max(0, servicesPerYear)) : 0;
     return {
       key: task?.id || `interval_${index}`,
       name,
@@ -8314,63 +8801,74 @@ function computeCostModel(){
     totalApprovedOrders += approved;
     const resolvedISO = req.resolvedAt || req.createdAt || null;
     const resolved = resolvedISO ? parseDateLocal(resolvedISO) : null;
     const resolvedLabel = resolved ? resolved.toLocaleDateString() : "—";
     let statusLabel = "Pending";
     if (req.status === "approved") statusLabel = "Approved";
     else if (req.status === "denied") statusLabel = "Denied";
     else if (req.status === "partial") statusLabel = "Partial";
     return {
       id: req.id,
       code: req.code || req.id || "Order",
       resolvedLabel,
       statusLabel,
       approvedLabel: formatterCurrency(approved, { decimals: approved < 1000 ? 2 : 0 }),
       requestedLabel: formatterCurrency(requested, { decimals: requested < 1000 ? 2 : 0 })
     };
   });
 
   const orderRequestSummary = {
     totalApprovedLabel: formatterCurrency(totalApprovedOrders, { decimals: totalApprovedOrders < 1000 ? 2 : 0 }),
     requestCountLabel: String(orderRows.length),
     rows: orderRows.slice(0, 6),
     emptyMessage: orderRows.length ? "" : "Approve or deny order requests to build the spend log."
   };
 
+  const downtimeInsight = downtimeDailyRaw.length
+    ? "Downtime cost combines task spend with lost profit based on overlapping cutting jobs or the fallback loss rate when no jobs are scheduled."
+    : "Add down time hours to maintenance tasks to measure lost production alongside task cost.";
+
   return {
     summaryCards,
     timeframeRows,
     forecastBreakdown,
     timeframeNote,
     historyRows,
     historyEmpty,
     jobSummary,
     jobBreakdown,
     jobEmpty,
     chartNote,
     chartInfo,
     orderRequestSummary,
+    downtimeSummary: {
+      baseRate: downtimeBaseRate,
+      baseRateLabel: downtimeBaseRateLabel,
+      rows: downtimeRows,
+      insight: downtimeInsight,
+      dailyEntries: downtimeDailyEntries
+    },
     chartColors: COST_CHART_COLORS,
     maintenanceSeries,
     jobSeries
   };
 }
 
 function drawCostChart(canvas, model, show){
   if (!canvas) return;
   const ctx = canvas.getContext("2d");
   const hitTargets = [];
   canvas.__costChartTargets = hitTargets;
   const W = canvas.width;
   const H = canvas.height;
   ctx.clearRect(0,0,W,H);
   ctx.fillStyle = "#fff";
   ctx.fillRect(0,0,W,H);
 
   const active = [];
   if (show.maintenance && model.maintenanceSeries.length){
     active.push({ key:"maintenance", color:model.chartColors.maintenance, points:model.maintenanceSeries });
   }
   if (show.jobs && model.jobSeries.length){
     active.push({ key:"jobs", color:model.chartColors.jobs, points:model.jobSeries });
   }
 
diff --git a/js/views.js b/js/views.js
index 3880a23c9388ee21691785aa22cb2018de177b08..69e7dfaf1d2484c2181cd6265fe5afbcfd49053d 100644
--- a/js/views.js
+++ b/js/views.js
@@ -210,50 +210,51 @@ function viewDashboard(){
           </div>
           <label>Maintenance task<select id="dashTaskExistingSelect"></select></label>
           <p class="small muted">Pick a task saved in Maintenance Settings to schedule it on the calendar.</p>
           <p class="small muted" data-task-existing-empty hidden>No maintenance tasks yet. Create one below to get started.</p>
           <p class="small muted" data-task-existing-search-empty hidden>No tasks match your search. Try a different name.</p>
           <div class="modal-actions">
             <button type="button" class="secondary" data-step-back>Back</button>
             <button type="submit" class="primary">Add to Calendar</button>
           </div>
         </form>
 
         <form id="dashTaskForm" class="modal-form" data-task-variant="new" hidden>
           <div class="modal-grid">
             <label>Task name<input id="dashTaskName" required placeholder="Task"></label>
             <label>Type<select id="dashTaskType">
               <option value="interval">Per interval</option>
               <option value="asreq">As required</option>
             </select></label>
             <label data-task-frequency>Frequency (hrs)<input type="number" min="1" step="1" id="dashTaskInterval" placeholder="e.g. 40"></label>
             <label data-task-last>Hours since last service<input type="number" min="0" step="0.01" id="dashTaskLast" placeholder="optional"></label>
             <label data-task-condition hidden>Condition / trigger<input id="dashTaskCondition" placeholder="e.g. When clogged"></label>
             <label>Manual link<input type="url" id="dashTaskManual" placeholder="https://..."></label>
             <label>Store link<input type="url" id="dashTaskStore" placeholder="https://..."></label>
             <label>Part #<input id="dashTaskPN" placeholder="Part number"></label>
             <label>Price ($)<input type="number" min="0" step="0.01" id="dashTaskPrice" placeholder="optional"></label>
+            <label>Down time (hrs)<input type="number" min="0" step="0.25" id="dashTaskDowntime" placeholder="optional"></label>
             <label>Category<select id="dashTaskCategory"></select></label>
             <label>Calendar date<input type="date" id="dashTaskDate"></label>
           </div>
 
           <div class="subtask-section">
             <div class="subtask-header">
               <h5>Sub-tasks</h5>
               <button type="button" id="dashAddSubtask" class="subtask-add-btn">+ Add sub-task</button>
             </div>
             <div id="dashSubtaskList" class="subtask-list"></div>
             <p class="small muted">Sub-tasks inherit the calendar display and live under the main task.</p>
           </div>
 
           <div class="modal-actions">
             <button type="button" class="secondary" data-step-back>Back</button>
             <button type="submit" class="primary" data-task-submit>Create Task</button>
           </div>
         </form>
       </section>
 
       <section class="dash-modal-step" data-step="downtime" hidden>
         <h4>Mark machine down time</h4>
         <form id="dashDownForm" class="modal-form">
           <div class="modal-grid">
             <label>Down time date<input type="date" id="dashDownDate" required></label>
@@ -972,109 +973,127 @@ function viewCosts(model){
   const efficiencyWindows = (Array.isArray(TIME_EFFICIENCY_WINDOWS) && TIME_EFFICIENCY_WINDOWS.length)
     ? TIME_EFFICIENCY_WINDOWS
     : [
         { key: "7d", label: "1W", days: 7, description: "Past 7 days" },
         { key: "30d", label: "1M", days: 30, description: "Past 30 days" },
         { key: "90d", label: "3M", days: 90, description: "Past 3 months" },
         { key: "182d", label: "6M", days: 182, description: "Past 6 months" },
         { key: "365d", label: "1Y", days: 365, description: "Past year" }
       ];
   const efficiencyButtons = efficiencyWindows.map((win, index) => {
     const days = Number(win?.days) || 0;
     const label = esc(win?.label ?? `${days || ""}`);
     const description = esc(win?.description ?? (days ? `Past ${days} days` : "Selected window"));
     const isActive = index === 0;
     return `
       <button type="button" class="time-efficiency-toggle${isActive ? " is-active" : ""}" data-efficiency-range="${esc(String(days))}" data-efficiency-range-label="${description}" aria-pressed="${isActive ? "true" : "false"}" title="${description}">
         ${label}
       </button>
     `;
   }).join("");
   const defaultEfficiencyDescription = esc(efficiencyWindows[0]?.description || "Past 7 days");
 
   const cards = Array.isArray(data.summaryCards) ? data.summaryCards : [];
   const timeframeRows = Array.isArray(data.timeframeRows) ? data.timeframeRows : [];
   const historyRows = Array.isArray(data.historyRows) ? data.historyRows : [];
+  const downtimeSummary = data.downtimeSummary || {};
+  const downtimeRows = Array.isArray(downtimeSummary.rows) ? downtimeSummary.rows : [];
   const jobBreakdown = Array.isArray(data.jobBreakdown) ? data.jobBreakdown : [];
   const jobSummary = data.jobSummary || { countLabel:"0", totalLabel:"$0", averageLabel:"$0", rollingLabel:"$0" };
   const chartColors = data.chartColors || { maintenance:"#0a63c2", jobs:"#2e7d32" };
   const chartInfo = data.chartInfo || "Maintenance cost line spreads interval pricing and approved as-required spend across logged machine hours; cutting jobs line tracks the rolling average gain or loss per completed job to spotlight margin drift.";
   const orderSummary = data.orderRequestSummary || {};
   const orderRows = Array.isArray(orderSummary.rows) ? orderSummary.rows : [];
   const overviewInsight = data.overviewInsight || "Totals blend the latest maintenance allocations, consumable burn rates, downtime burdens, and job margin data so you always see current cost exposure.";
   const ordersInsight = data.ordersInsight || "Tracks every waterjet part request from submission through approval so finance can confirm spend and spot stalled orders.";
   const timeframeInsight = data.timeframeInsight || "Usage windows combine logged machine hours with interval pricing to estimate what each upcoming maintenance window will cost.";
   const historyInsight = data.historyInsight || "Shows the latest completed maintenance, combining hours logged and reconciled spend to highlight cost spikes.";
   const efficiencyInsight = data.efficiencyInsight || "Summarizes cutting job profitability by tying revenue to labor, material, consumable, and overhead allocations so you can act on true margins.";
+  const downtimeInsight = downtimeSummary.insight || "Track how maintenance downtime combines lost production with task costs across common review windows.";
   const breakdown = data.forecastBreakdown || {};
   const breakdownSections = Array.isArray(breakdown.sections) ? breakdown.sections : [];
   const breakdownTotals = breakdown.totals || {};
   const hasSections = breakdownSections.length > 0;
   const hasTotals = Boolean(
     breakdownTotals && (
       breakdownTotals.intervalLabel ||
       breakdownTotals.asReqLabel ||
       breakdownTotals.combinedLabel
     )
   );
   const forecastNote = breakdown.note || "Add pricing to maintenance tasks and approve order requests to enrich the forecast.";
 
   const renderSummaryCard = (card = {})=>{
     const key = card && card.key ? String(card.key) : "";
     const isForecast = key === "maintenanceForecast";
     const isCutting = key === "cuttingJobs";
     const classes = ["cost-card"];
     const attrParts = [`class="${classes.join(" ")}"`];
     if (key){
       attrParts.push(`data-card-key="${esc(key)}"`);
     }
     if (isForecast){
       attrParts.push("role=\"button\"");
       attrParts.push("tabindex=\"0\"");
     }
     if (isCutting){
       attrParts.push("data-cost-cutting-card=\"\"");
       attrParts.push("role=\"link\"");
       attrParts.push("tabindex=\"0\"");
     }
     const attr = attrParts.join(" ");
     return `
               <div ${attr}>
                 <div class="cost-card-icon">${esc(card.icon || "")}</div>
                 <div class="cost-card-body">
                   <div class="cost-card-title">${esc(card.title || "")}</div>
                   <div class="cost-card-value">${esc(card.value || "")}</div>
                   <div class="cost-card-hint">${esc(card.hint || "")}</div>
                 </div>
               </div>
             `;
   };
 
   const summaryCardsHTML = cards.length
     ? cards.map(renderSummaryCard).join("")
     : `<p class="small muted">No cost metrics yet. Log machine hours and add pricing to interval tasks.</p>`;
 
+  const downtimeTableHTML = downtimeRows.length ? `
+    <table class="cost-table">
+      <thead><tr><th>Window</th><th>Current loss</th><th>Projected loss</th></tr></thead>
+      <tbody>
+        ${downtimeRows.map(row => `
+          <tr>
+            <td>${esc(row.label || "")}</td>
+            <td>${esc(row.actualLabel || "")}</td>
+            <td>${esc(row.projectedLabel || "")}</td>
+          </tr>
+        `).join("")}
+      </tbody>
+    </table>
+  ` : `<p class="small muted">Add down time hours to maintenance tasks to project opportunity cost.</p>`;
+
   const forecastTableHTML = (hasSections || hasTotals)
     ? `
       <div class="forecast-table-wrap">
         <table class="forecast-table">
           <thead>
             <tr>
               <th scope="col">Task</th>
               <th scope="col">Cadence</th>
               <th scope="col">Unit cost</th>
               <th scope="col">Annual estimate</th>
             </tr>
           </thead>
           <tbody>
             ${breakdownSections.map(section => {
               const rows = Array.isArray(section.rows) ? section.rows : [];
               const headerRow = `
               <tr class="forecast-section-row">
                 <th scope="rowgroup" colspan="4">
                   <span class="forecast-section-header">
                     <span class="forecast-section-title">${esc(section.label || "")}</span>
                     ${section.totalLabel ? `<span class="forecast-section-total">${esc(section.totalLabel)}</span>` : ""}
                   </span>
                 </th>
               </tr>`;
               const rowsHtml = rows.length
@@ -1209,50 +1228,72 @@ function viewCosts(model){
               <h3>Estimated Cost Trends</h3>
             </div>
             <div class="cost-chart-toggle">
               <label><input type="checkbox" id="toggleCostMaintenance" checked> <span class="dot" style="background:${esc(chartColors.maintenance)}"></span> Maintenance</label>
               <label class="cost-chart-toggle-jobs"><input type="checkbox" id="toggleCostJobs" checked> <span class="dot" style="background:${esc(chartColors.jobs)}"></span> <span class="cost-chart-toggle-link" role="link" tabindex="0">Cutting jobs</span></label>
             </div>
           </div>
           <div class="cost-chart-canvas">
             <canvas id="costChart" width="780" height="240"></canvas>
           </div>
           ${data.chartNote ? `<p class="small muted">${esc(data.chartNote)}</p>` : `<p class="small muted">Toggle a line to explore how maintenance and job efficiency costs evolve over time.</p>`}
           <div class="cost-window-insight">
             <div class="chart-info">
               <button type="button" class="chart-info-button" aria-describedby="costChartInfo" aria-label="Explain Estimated Cost Trends">
                 <span aria-hidden="true">?</span>
                 <span class="sr-only">Show how the Estimated Cost Trends chart is calculated</span>
               </button>
               <div class="chart-info-bubble" id="costChartInfo" role="tooltip">
                 <p>${esc(chartInfo)}</p>
               </div>
             </div>
           </div>
         </div>
       </div>
 
+      <div class="dashboard-window" data-cost-window="downtime">
+        <div class="block">
+          <h3>Maintenance Downtime Impact</h3>
+          <div class="downtime-rate">
+            <span class="downtime-rate-value">Fallback loss rate: ${esc(downtimeSummary.baseRateLabel || "$150/hr")}</span>
+            <button type="button" class="time-efficiency-edit-btn" data-edit-downtime-rate>Edit</button>
+          </div>
+          ${downtimeTableHTML}
+          <div class="cost-window-insight">
+            <div class="chart-info">
+              <button type="button" class="chart-info-button" aria-describedby="costDowntimeInsight" aria-label="Explain Maintenance Downtime Impact table">
+                <span aria-hidden="true">?</span>
+                <span class="sr-only">Show how Maintenance Downtime Impact is calculated</span>
+              </button>
+              <div class="chart-info-bubble" id="costDowntimeInsight" role="tooltip">
+                <p>${esc(downtimeInsight)}</p>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+
       <div class="dashboard-window" data-cost-window="orders">
         <div class="block">
           <h3>Waterjet Part Summary</h3>
           <div class="cost-jobs-summary order-cost-summary">
             <div><span class="label">Requests logged</span><span>${esc(orderSummary.requestCountLabel || "0")}</span></div>
             <div><span class="label">Approved spend</span><span>${esc(orderSummary.totalApprovedLabel || "$0.00")}</span></div>
           </div>
           ${orderRows.length ? `
             <table class="cost-table">
               <thead><tr><th>Request</th><th>Resolved</th><th>Status</th><th>Approved $</th><th>Requested $</th></tr></thead>
               <tbody>
                 ${orderRows.map(row => `
                   <tr>
                     <td>${esc(row.code || "Order")}</td>
                     <td>${esc(row.resolvedLabel || "—")}</td>
                     <td>${esc(row.statusLabel || "")}</td>
                     <td>${esc(row.approvedLabel || "$0.00")}</td>
                     <td>${esc(row.requestedLabel || "$0.00")}</td>
                   </tr>
                 `).join("")}
               </tbody>
             </table>
           ` : `<p class="small muted">${esc(orderSummary.emptyMessage || "Approve or deny order requests to build the spend log.")}</p>`}
           <div class="cost-window-insight">
             <div class="chart-info">
diff --git a/style.css b/style.css
index 31b66aa8916e3946eaf9d9e3d0d04f7be07de6d7..7804f6cef21eb15ab79e6de34675fc25fcef38bf 100644
--- a/style.css
+++ b/style.css
@@ -454,50 +454,52 @@ body.pump-notes-open { overflow:hidden; }
   font-weight:600;
   color:#0b1a38;
   font-variant-numeric:tabular-nums;
 }
 .forecast-empty-row td{
   text-align:center;
   font-style:italic;
   color:#5b6b87;
 }
 .forecast-grand-total-row{
   font-weight:700;
   font-size:14px;
 }
 .forecast-table-note{ font-size:12px; color:#1e3352; margin:0; }
 body.forecast-modal-open{ overflow:hidden; }
 
 @media (max-width: 720px){
   .forecast-modal-card{ padding:24px 20px; border-radius:18px; }
   .forecast-table th,
   .forecast-table td{ padding:10px 12px; }
 }
 
 .cost-table{ width:100%; border-collapse:collapse; font-variant-numeric:tabular-nums; }
 .cost-table th, .cost-table td{ padding:8px; border:1px solid #e1e5ee; text-align:left; }
 .cost-table th{ background:#f4f7fb; font-weight:600; color:#3b475f; }
+.downtime-rate{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin-bottom:12px; }
+.downtime-rate-value{ font-weight:600; color:#0a1f3f; }
 
 .cost-history{ list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:8px; }
 .cost-history li{
   display:flex;
   align-items:center;
   gap:12px;
   padding:10px 12px;
   background:rgba(255, 255, 255, 0.75);
   border:1px solid rgba(255, 255, 255, 0.35);
   border-radius:12px;
   font-variant-numeric:tabular-nums;
   box-shadow:0 12px 24px rgba(6, 24, 64, 0.18);
   cursor:pointer;
   transition:transform .12s ease, box-shadow .12s ease;
 }
 .cost-history-main{
   flex:1;
   display:grid;
   grid-template-columns:repeat(3,minmax(0,1fr));
   gap:8px;
 }
 .cost-history li:hover{ box-shadow:0 16px 28px rgba(6,24,64,0.24); transform:translateY(-1px); }
 .cost-history li:focus-visible{ outline:2px solid rgba(10,99,194,0.6); outline-offset:2px; }
 .cost-history li[data-task-missing]{ border-style:dashed; }
 .cost-history-date{ text-align:left; }
 
EOF
)
